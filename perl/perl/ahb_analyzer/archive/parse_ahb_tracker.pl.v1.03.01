#!/tools/sw/perl/bin/perl -w

# Author    Lutz Filor
# Phone     408 807 6915
#
# Purpose   Analysis AHB-tracker tracefile
#
# Revision  VERSION     DATE            Description
# ================================================================================================
# History   1.01.01     09/10/2018      Parsing trace files
#           1.01.02     09/14/2018      First   report file, build data structure first check in
#                                       Min, Max, Average
#           1.01.03 -   09/21/2018      Refactor parsing, analysis, reporting second check in
#                                       split -> REGEX, Header parsing, Parsing.log
#           1.01.04 -   09/24/2018      Add and fix payload analysis, timebase, beat unaligned
#                                       Next ADDR transfer report before concurrent DATA transfer
#           1.01.05 -   09/25/2018      Add transfer analysis, transfer, beat, WAIT states, IDLE,
#                                       and concealed ADDR transfers
#           1.01.06     09/26/2018      Refactor latency analysis
#                                       Refactoring latency_analysis()
#                                       Accounting  1st DATA, Last Data latency
#       3   1.01.07     09/27/2018      Update analysis report
#                                       Debugging   latency analysis()
#                                       Refactoring bandwidth analysis()
#       4   1.01.08     09/28/2018      Document transfer pointer list/data structure
#                                       Refactor    build command/data object()
#                                       Create      elaborate_tracefile()
#       5   1.02.01     10/01/2018      Add Command line interface
#                                       Revise      Analysis Report 
#       6   1.02.02     10/01/2018      Refactor    transaction_analysis(),
#                                       refactor    report_transaction()
#       7   1.02.03     10/02/2018      Develop     timebased windowing trace input file
#           1.02.04     10/03/2018      Debugging   timebased windowing trace input file
#                                                   add default total trace
#           1.02.05     10/04/2018      Insert new  commandline control, change parameter list
#                                       Refactor    elaborate_tracefile()
#                                       Refactor    initialize_payload_analysis(), reformat logs
#                                       Refactor    bandwidth_analysis()
#           1.02.06     10/05/2018      Refactor    transaction_analysis()
#                                       Refactor    transfer_analysis()
#                                       Refactor    analysis_report()
#                                       Remove      protocol_trace_analysis()
#                                       Remove      test_AHB_hash() ->  transaction_analysis()
#                                       Remove      deprecated data structure %ahb_anal
#                                       Remove      deprecated data structure %ahb_band
#                                       Remove      deprecated data structure %ahb_latency
#       8  1.03.01     10/08/2018                            

my $VERSION = "1.03.01";

use strict;
use warningsm

use feature 'state';                    # Static local variables

use Readonly;
use Getopt::Long;
#use Padwalker;                         # Not available/installed
#use Package::Stash;                     # available
#use Pod::Usage;                         # available

#use DateTime;                          # Not used

sub usage;
sub report;
sub parse_header;
sub calculate_payload;
sub elaborate_tracefile;

Readonly my $DIGITS => qr { \d+ (?: [.] \d*)? | [.] \d+ }xms;
Readonly my $SIGN   => qr { [+-] }xms;
Readonly my $EXPO   => qr { [eE] $SIGN? \d+ }xms;
Readonly my $FLOAT  => qr { ($SIGN?) ($DIGITS) ($EXPO?) }xms;

#  
#  Convert global variable to local state variable
#

my $ptr_fst_cmd     = undef;                                # pointer to first              command object/transaction
my $ptr_ant_cmd     = undef;                                # pointer to antepenultimate    command object/transaction
my $ptr_pen_cmd     = undef;                                # pointer to penultimate        command object/transaction <= SINGLE Transfer 
my $ptr_prv_cmd     = undef;                                # pointer to previous           command object/transaction 
my $ptr_cur_cmd     = undef;                                # pointer to current            command object/transaction 
my $ptr_nxt_cmd     = undef;                                # pointer to next               command object/transaction 
my $ptr_lst_cmd     = undef;                                # pointer to last               command object/transaction 
my $win_str_ptr     = undef;                                # pointer to start  analysis    window
my $win_stp_ptr     = undef;                                # pointer to stop   analysis    window

my $ptr_fst_dta     = undef;                                # pointer to first    data obj
my $ptr_prv_dta     = undef;
my $ptr_cur_dta     = undef;                                # pointer to current  data obj/transaction
my $ptr_nxt_dta     = undef;
my $ptr_lst_dta     = undef;                                # pointer to last     data obj

my %pointer =   (   first           =>  \$ptr_fst_cmd,      # Head   of transaction list
                    previous        =>  \$ptr_prv_cmd,      #           predecessor transaction
                    current         =>  \$ptr_cur_cmd,      # pointer   actual      transaction
                    next            =>  \$ptr_nxt_cmd,      #           successor   transaction
                    antepenultimate =>  \$ptr_ant_cmd,      # third  last
                    penultimate     =>  \$ptr_pen_cmd,      # second last
                    ultimate        =>  \$ptr_lst_cmd,      #        last
                    last            =>  \$ptr_lst_cmd,      # Tail   of transaction list
                    start           =>  \$win_str_ptr,      # Begin  of analysis    window
                    stop            =>  \$win_stp_ptr,      # End    of analysis    window
                );
my %opts    =   (  #from            =>   optional,          # Optional Command line options -- No default settings
                   #until           =>   optional,          # Optional Command line options -- No default settings
                   #debug           =>   optional,                                          -- No default settings
                    parse           =>  'parser.log',       # Default logname for parsing input trace file
                    build           =>  'build.log',        # Default logname for building trace transaction/transfer list
                    transfer        =>  'transfer.log',     # Default logname for transfers, type (IDLE,ADDR,DATA,BUSY) and duration
                    payload         =>  'payload.log',      # Default logname for payload analysis initialize_payload_analysis()
                    transaction     =>  'transaction.log',  # Default logname for transaction analysis, by direction, type and size
                    latency         =>  'latency.log',      # Default logname for latency     analysis, ( from, to ) window
                    bandwidth       =>  'bandwidth.log',    # Default logname for bandwidth   analysis, ( from, to ) window
                    window          =>  'window.log',       # Default logname for determine the trace window within the trace file
                    report          =>  'analysis.rpt',     # Default logname for analysis report
                    errlog          =>  'error.log',        # Default logname for reporting on input trace file errors
                );
my %defines;                                                # Command line defines

my %Trace;                                                  # Trace file header information
my %AHB_hash;                                               # Trace file transfer information              LEGACY
                                                            # access AHB command transfers via time stamp

my %ahb_transfer_new;                                       #        AHB transfer    analysis new
my %ahb_latency_new;                                        #        AHB latency     analysis new/refactored
my %ahb_bandwidth_new;                                      #        AHB bandwidth   analysis new/refactored
my %ahb_transaction_new;                                    #        AHB transaction analysis new/refactored

my $progress_log    = 'progress.log';                       # log    progress phases of program
#my $analysis        = 'analysis.rpt';                       # access data via pointer; report file

#################################################################################################################################
my $error_log       = 'error.log';                          # log    trace file reporting errors

#|             6127040 ps|             6132066 ps|RD-DATA   | 84D5214C |  3/ 4 | -- | 00000000 |  OKAY  | ---- | ------- | - | ---------- |
#|             6132066 ps|             6137066 ps|WR-NONSEQ | 84D52332 | ----- | 16 | -------- |  ----  |INCR16|    1    | 8 |           0|
#|             6132066 ps|             6137066 ps|RD-DATA   | 84D52150 |  1/ 4 | -- | 00000000 |  OKAY  | ---- | ------- | - | ---------- |
#|             6137066 ps|             6142066 ps|WR-DATA   | 84D52332 |  2/16 | -- | ..A3.... |  OKAY  | ---- | ------- | - | ---------- |
#                                                                         ....
#|             6206870 ps|             6211870 ps|WR-DATA   | 84D52340 | 16/16 | -- | ......EE |  OKAY  | ---- | ------- | - | ---------- |
#|             6211870 ps|             6216946 ps|WR-DATA   | 84D52341 | 17/16 | -- | ....48.. |  OKAY  | ---- | ------- | - | ---------- |
#|             6216946 ps|             6221846 ps|RD-NONSEQ | 84D52248 | ----- | 16 | -------- |  ----  |INCR16|    4    | 4 |           0|
#|             6221846 ps|             6226746 ps|RD-DATA   | 84D52248 |  1/16 | -- | 00000000 |  OKAY  | ---- | ------- | - | ---------- |

#################################################################################################################################
#                    'transfer.log                           # tbd    handle for cvs file handle     transfer log
#my $trans_log     = 'transaction.log';                      # tbd    handle not used                transaction log/command log    
#my $data_tracer   = 'ahb_data.log';                         # tbd    handle for csv file handle     transfer log

my $owner         = 'Lutz Filor';

my ($s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst) = localtime;

open (my $proh, ">$progress_log")   || die " Can not create log $progress_log";         # Progress logfile
#open (my $cmdh, ">$transaction_log")|| die " Can not create log $transaction_log";      # Split & sort transactions/commands by direction, type & size
#################################################################################################################################
#open (my $dath, ">$data_tracer")    || die " Can not create log $data_tracer";          # If transported data becomes relevant,
#open (my $tsth, ">$ahb_testlog")    || die " Can not create log $ahb_testlog";          # Testing AHB command hash data structure


#
# main entry
#
#=================================================================================================================================

GetOptions (    'help|h|?'          =>  \&help,
                'info'              =>  \$opts{info},
                'debug'             =>  \$opts{debug},
                'trace|t=s'         =>  \$opts{trace},      
                'from=i'            =>  \$opts{from},
                'until=i'           =>  \$opts{until},
                'directory|dir=s'   =>  \$opts{dir},                    # Specify directory w/ trace files
           );                                                           # Command Line Processor



if ( !defined $opts{trace} ) {
    printf " ... command line option --trace=filename not found\n";
    exit;
} else {
    # 
    # Parsing   AHB trace file
    # Building   2D directed graph/list of AHB (ADDR, DATA) transfers
    #
    elaborate_tracefile         (  \%Trace                  # Output    Extracting    trace file header information
                                ,  \%pointer                #           Pointer into  trace transfer double pointered list 
                                ,  \%opts               );  # Input     Options list  from command line
}


if ( defined $opts{info} ) {
    report_info                 (  \%Trace                  # Trace   information from file header
                                ,  \%pointer                # Pointer information
                                ,  \%opts               );  # Command line options
    # exit;                                                 # Exit    after info report
}#

initialize_latency_analysis     ( \%ahb_latency_new     );  # Output    Initialize reporting structure
initialize_transaction_analysis ( \%ahb_transaction_new );  # Output    Initialize reporting structure

#
# determine burst length and calculate payload per transaction
#
initialize_payload_analysis     (  \%Trace                  # Input     Trace   information from trace file header
                                ,  \%pointer                #           Pointer information into transfer/trace list
                                ,  \%opts               );  #           Command line options
                                                            # Output    Augmentation of transfer list

           transfer_analysis    (  \%Trace                  # Input     Trace Header information
                                ,  \%pointer                #           Pointer information into transfer/trace list
                                ,  \%opts                   #           Command line options
                                ,  \%ahb_transfer_new   );  # Output    Transfer analysis, IDLE, WAIT states, BEAT

           latency_analysis     (  \%Trace                  # Input     Trace Header information
                                ,  \%pointer                #           Pointer information into transfer/trace list
                                ,  \%opts                   #           Command line options
                                ,  \%ahb_transfer_new       #           Transfer analysis IDLE, WAIT states, BEATs
                                ,  \%ahb_latency_new     ); # Output    Latency  analysis ( From, To )      

           bandwidth_analysis   (  \%Trace                  # Input     Trade Header information
                                ,  \%pointer                #           Pointer information into transfer/trace list
                                ,  \%opts                   #           Command line options
                                ,  \%ahb_transfer_new       #           Transfer analysis IDLE, WAIT states, BEATs
                                ,  \%ahb_bandwidth_new      # Output    Bandwidth analysis (From, To )
                                ,  \%ahb_transaction_new ); #           Transaction statistic

           transaction_analysis (  \%Trace                  # Input     Trace Header information
                                ,  \%AHB_hash               #           Reference to transfer list 
                                ,  \%opts                   #           Command line options
                                ,  \%ahb_transaction_new ); # Output    Transaction reporting, replacing %ahb_anal

analysis_report                 (  \%Trace                  # Input     Trade Header information
                                ,  \%opts                   #           Command line options
                                ,  \%ahb_latency_new        #           Latency analysis
                                ,  \%ahb_transfer_new       #           Transfer analysis   to be deprecated
                                ,  \%ahb_bandwidth_new      #           Bandwidth analysis
                                ,  \%ahb_transaction_new ); #           Transaction analysis

exit;

info_report                     ( \%Trace
                                , \%pointer                 # all pointer
                                , \%opts               );
#=================================================================================================================================
# End of main() 

# Testing specified data structures

#test_AHB_hash();                               # Testing data structure
#report();                                      # This report is for debugging purposes

#
# Subroutine implementation
#
#=================================================================================================================================
sub usage{
    printf "\n";
   #printf " Usage : <command>             <tracker_trace.file>  <start_time> <trace>\n";
   #printf "          parse_ahb_tracker.pl  log_file_name         key_value    access_data [0..12] range\n";
    printf " Usage : <command>             <tracker_trace.file> \n";
    printf "          parse_ahb_tracker.pl  log_file_name       \n";
    printf "\n";
    printf " Trace : Tracker-field selected by          column# or Name <string>   \n";
    printf " ------------------------------------------------------------------------\n";
    printf "         Nonseq/Seq assert Time          :        0 || nonseq_assert_time\n";
    printf "         HREADY     assert Time          :        1 || hready_assert_time\n";
    printf "         DIR PHASE                       :        2 || dir_phase\n";
    printf "         ADDRESS                         :        3 || address\n";
    printf "         BEAT NUM                        :        4 || beat_num\n";
    printf "         LEN                             :        5 || burst_len\n";
    printf "         DATA                            :        6 || data\n";
    printf "         RESPONSE                        :        7 || response\n";
    printf "         BURST Type                      :        8 || burst_type\n";
    printf "         BURST Size                      :        9 || burst_size\n";
    printf "         HPORT                           :       10 || hport\n";
    printf "         Next     command                :       11 || next_command\n";
    printf "         Previous command                :       12 || prev_command\n";
    printf "\n";
    exit 0;
}#sub usage


sub   elaborate_tracefile {
      my ( $trace_header_ref                    # Trace information
         , $ptr_ref                             # transaction trace pointer
         , $opts_ref      ) = @_;               # command line arguments


      my $cycle       = ${$trace_header_ref}{period};                       # (float)
      my $tb          = ${$trace_header_ref}{timebase};                     # =  $6; # (ns|ps)
      my $frequency   = ${$trace_header_ref}{frequency};                    # (float)
      my $fb          = ${$trace_header_ref}{freqbase};                     # (MHz|GHz)
      my $tracefile   = ${$opts_ref}{trace};
      my $parselog    = ${$opts_ref}{parse};
      my $buildlog    = ${$opts_ref}{build};
      my $transaction = 0;

      open ( my $TRACE, "<$tracefile")     || die " Can not open input $tracefile";
      printf $proh " Author : %s\n", $owner;
      printf $proh "\n";
      printf $proh " ... opening trace file %s\n", $opts{trace};                  # $filename;
      printf $proh "     reading trace file\n";

      my @LINES = <$TRACE>;                     # Slurp trace file into array
      my $eof   = $.;                           # Last line number, w/ File record separator <\n>
      close ( $TRACE );                         # 

      printf $proh " ... closing trace file\n";
      printf $proh "     opening ParserLogFile  %s\n", $parselog;
      printf $proh "     opening BuildLogFile   %s\n", $buildlog;

      open (my $parh, ">$parselog")     || die " Can not create log $parselog";
      open (my $buih, ">$buildlog")     || die " Can not create log $buildlog";

      for (my $i = 0; $i < $eof; $i++)
      {
          my @COL;
          my $row      = $LINES[$i];
          chomp $row;
         
          if ( $i <=  9) {
              printf $buih  " ... HEADER decoding\n"      if ($i == 0);
             #printf $proh  " ... HEADER decoding\n"      if ($i == 0);
              parse_header      (  $row                             # input     trace file row/line
                                ,  $i                               #           row/line index/count
                                ,  $parh                            #           file handle parse log  
                                ,  \%Trace );                       # output    extracted trace file header information
              printf $buih  "     line :: %5s :: %s\n", $i, $row;
              printf $buih  " ... HEADER decoding done\n" if ($i ==  9);
              printf $proh  "     HEADER decoding done\n" if ($i ==  9);
          }
          if ( $i >= 10) {
             #printf $proh  " ... TABLE  decoding ... \n" if ($i == 10);
              printf $buih  " ... TABLE  decoding ... \n" if ($i == 10);
              printf $buih  "     line :: %5s :: %s\n", $i, $row;
      
              parse_body        (  $row                             # input     trace file row/line
                                ,  $parh                            #           file handle parse log  
                                ,  \@COL );                         # output    extracted column data of transfer table rows
      
              if ( $COL[4] =~ /NONSEQ/ ) {                          # PHASE Address
      
                  $AHB_hash{$COL[0]}                                # hash of AHB command, w/ command ASSERT time as access keys
                  = build_command_obj   ( \@COL                     # input     addr transfers/AHB command objects, in double ptr list V.01.01.08
                                        , $buih );
              }# NONSEQ aka address phase or command
      
              if ( $COL[4] =~ /DATA|BUSY/ ) {                       # PHASE Data
                 
                  build_data_obj        ( \@COL                     # input     data transfers --> via AHB address/cmd transfers
                                        , $buih );                  #           file handle building log
              }# Data phase or Data
          }# process trace table $i >= 10
      }# for AHB trace tracker
      
      #close( FILE );
      printf "\n";
      #printf        " ... done reading AHB trace tracker\n";
      printf "\n";
      printf $buih  " ... TABLE  decoding done\n";
      printf $proh  "     TABLE  decoding done\n";
      close( $parh );
      close( $buih );
      printf $proh  "     close  parse log\n";
      printf $proh  "     close  build log\n";
      printf $proh  " ... elaborate trace file done\n";
      printf $proh  "\n";
}#sub elaborate_tracefile


sub parse_header{
    my ( $row                                   # input     row Tables have rows and columns
       , $lc                                    #           row/line count
       , $parh                                  #           file handle to parse log
       , $trace_header_ref  ) = @_;             # output    extracted trace file header info

    #
    # Instance: uvm_test_top.top_env_i.ahbfab_env_i.mvc_ahb_mst_5_env_i.logger_handle_ahb
    #

    if ($lc == 0) {
        if ( $row =~ /^Instance:\s+([a-z0-9_.]+)/x ) {
            printf  $parh "   Picked  : %s :: Header\n", $row;
            printf  $parh "             Instance: %s\n", $1;
            ${$trace_header_ref}{tracefile}    =  $1;                                  # extract trace filename
        } else {
            printf $parh "   Skipped : %s\n", $row;
        }
    }# parse first line

    #
    # AHB Clk Cycle = 5 ns; AHB Clk Frequency = 200.00 MHz; Data bus width = 32 bits
    #

    elsif ($lc == 1) {
        if ( $row =~ m{  ^(\w+)[ ]Clk[ ]Cycle    [ ]=[ ]($FLOAT)[ ] (ns|ps)     # <== Add Time base
                      ;[ ](\w+)[ ]Clk[ ]Frequency[ ]=[ ]($FLOAT)[ ](MHz|GHz)    # <== Add Frequency base
                      ;[ ] Data[ ]bus[ ]width    [ ]=[ ]  (\d+) [ ]   bits      # increase readability w/ x-modifier
                      }x ) 
        {
            printf $parh "   Picked  : %s\n", $row;
            printf $parh "%*s%s Clk Cycle = %s %s; %s Clk Frequency = %3.2f %s; Data bus width = %s bits\n"
                         ,13,'',$1, $2, $6, $7, $8, $12, $13;
            ${$trace_header_ref}{protocol}     =  $1; # (AHB)
            ${$trace_header_ref}{period}       =  $2; # (float)
            ${$trace_header_ref}{timebase}     =  $6; # (ns|ps)
            ${$trace_header_ref}{redundant}    =  $7; # (AHB)
            ${$trace_header_ref}{frequency}    =  $8; # (float)
            ${$trace_header_ref}{freqbase}     = $12; # (MHz|GHz)
            ${$trace_header_ref}{databus}      = $13; # bit width
        }# regex
        else {
            printf $parh "   Skipped : %s\n", $row;
            $row =~ m{  ^(\w+)[ ]Clk[ ]Cycle    [ ]=[ ]($FLOAT)[ ] (ns|ps)
                     ;[ ](\w+)[ ]Clk[ ]Frequency[ ]=[ ]($FLOAT)[ ](MHz|GHz)
                     ;[ ] Data[ ]bus[ ]width    [ ]=[ ]  (\d+) [ ]   bits
                     }x ;
            printf  $parh "%*s%s Clk Cycle = %s %s; %s Clk Frequency = %3.2f %s; Data bus width = %s bits\n"
                          ,13,'',$1, $2, $6, $7, $8, $12, $13;
            printf  $parh "       \$1 : %s\n", $1; # Protocol Period    (AHB)
            printf  $parh "       \$2 : %s\n", $2; #          FLOAT
            printf  $parh "       \$3 : %s\n", $3; #          Sign
            printf  $parh "       \$4 : %s\n", $4; #          Digits
            printf  $parh "       \$5 : %s\n", $5; #          Exponent
            printf  $parh "       \$6 : %s\n", $6; #          Timebase
            printf  $parh "       \$7 : %s\n", $7; # Protocol Frequency (AHB)
            printf  $parh "       \$8 : %s\n", $8; #          FLOAT
            printf  $parh "       \$9 : %s\n", $9; #          SIGN
            printf  $parh "       \$10: %s\n", $10;#          DIGITS
            printf  $parh "       \$11: %s\n", $11;#          Exponent
            printf  $parh "       \$12: %s\n", $12;#          Exponent
            printf  $parh "       \$13: %s\n", $13;# Databus  Width     (bit)         
        }
    }# parse second line
    else {
        printf $parh "   Skipped : %s\n", $row;
    }
}#sub parse_header

sub parse_body{
    my ( $row                                   # input     row/line from trace file
       , $parh                                  #           file handle to parse log
       , $a_ref   ) = @_;                       # output    extracted trace information

    # The commented code documents a failing regex and how to improve the parsing code, control and extract
    #if ( $LINES[$i] =~ m{\A                    # From  start of line beginning with <|>
    #if ( $row =~ m{#\A                         # From  start of line beginning with <|>
    #
    #              |\s+(\d+) ns                 # Column  2: Sample time HREADY Assert Time 
    #              |(\w+)\s+                    # Column  3: PHASE
    #              |\s([A-F0-9]{8})\s+          # Column  4: Address 32bit exact 8 Hex
    #              |\s([0-9\/\- ]+)             # Column  5: Beat number, extract string w/ subset char
    #              |\s([0-9-]+)                 # Column  6: LEN/Length, extract string w/ char subset
    #              |\s([A-F0-9\-\.])            # Column  7: DATA, text string       !! Not data
    #              |\s([A-F0-9\-)\s+            # Column  8: RESP/Response
    #              |(\w+)                       # Column  9: Burst Type SINGLE, WRAP4, INCR8 .. WRAP16
    #              |\s([0-9\-])\s               # Column 10: Burst Size, text string !! Not data
    #              |\s([A-F0-9]{1})             # Column 11: HPROT, Hex number
    #              |\s+([0-9\-]+)\s*|           # Column 12: HSEL, Slave index text string !! Not data
    #              \z                           # Until   end of line ending EOS                                      Shall match \A usage
    #COL                     1                       2          3          4       5    6          7        8      9        10  11           12
    #|              620521 ns|              620531 ns|WR-NONSEQ | 3FF115E7 | ----- |  8 | -------- |  ----  |WRAP8 |    1    | 3 |           0|
    #|              625571 ns|              625581 ns|WR-NONSEQ | 3FF114F0 | ----- |  ? | -------- |  ----  |INCR  |    2    | 8 |           0|
    #|             6026708 ps|             6031684 ps|WR-NONSEQ | 84D522B8 | ----- | 16 | -------- |  ----  |INCR16|    4    | B |           0|
    if ( $row =~ m{^[|]\s+  (\d+)            [ ]  (ns|ps)   # Column  1: Assert time SEQ Assert Time                         <== Parsing Extention timebase
                    [|]\s+  (\d+)            [ ]  (ns|ps)   # Column  2: Sample time HREADY Assert Time                      <== Parsing Extention timebase
                    [|]     ([A-Z-]+)        [ ]+           # Column  3: PHASE
                    [|]\s   ([A-F0-9]{8})    [ ]+           # Column  4: Address 32bit exact 8 Hex literals
                    [|]\s   ([0-9/ ?-]{5})   [ ]            # Column  5: Beat number, extract string w/ char subset          <== Parsing Error [0-9\/\- ] class subset 
                    [|]\s+  ([0-9-?]+)       [ ]            # Column  6: LEN/Length , extract string w/ char subset          <== Parsing Error, \s+, missing ?
                    [|]\s   ([A-F0-9\-\.]{8})[ ]            # Column  7: DATA, text string       !! Not data
                    [|]\s+  ([\-A-Z]+)       [ ]+           # Column  8: RESP/Response
                    [|]\s*  ([-A-Z0-9]+)     [ ]*           # Column  9: Burst Type SINGLE, WRAP4, INCR8 .. WRAP16, ' ---- '
                    [|]\s+  ([0-9\-]+)       [ ]+           # Column 10: Burst Size, text string !! Not data
                    [|]\s   ([-A-F0-9]{1})   [ ]            # Column 11: HPROT, Hex number
                    [|]\s+  ([0-9\-]+)\s*    [|]            # Column 12: HSEL, Slave index text string !! Not data
                  }xmsi                                     #        Allow comment, multi line (^,$), New line (.), case insensitive
       ) {                                                  # Parenterize correctly the matching condition
           printf $parh "   Picked  : %s\n", $row;
           push   $a_ref, ( $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14 );       # Index no longer match the columns
           printf $parh "%*s"          , 13, '';                                    #                  Pre timebase tracking
           printf $parh "|%20s %s"     , $a_ref->[ 0],$a_ref->[ 1];                 #$1 Assert time;            $a_ref->[ 0]
           printf $parh "|%20s %s"     , $a_ref->[ 2],$a_ref->[ 3];                 #   Complettime             $a_ref->[ 1]
           printf $parh "|%-10s"       , $a_ref->[ 4];                              #Transfer                   $a_ref->[ 2]
           printf $parh "| %-8s "      , $a_ref->[ 5];                              #ADDR                       $a_ref->[ 3]
           printf $parh "| %5s "       , $a_ref->[ 6];                              #BEAT                       $a_ref->[ 4]
           printf $parh "| %2s "       , $a_ref->[ 7];                              #LEN                        $a_ref->[ 5]
           printf $parh "| %8s "       , $a_ref->[ 8];                              #DATA                       $a_ref->[ 6]  
           printf $parh "|%6s  "       , $a_ref->[ 9];                              #RESP                       $a_ref->[ 7]
           if ( $a_ref->[10] =~ m/[-]/){ printf $parh "| %s "    , $a_ref->[10];    #BURST TYPE                 $a_ref->[ 8]
           } else {                      printf $parh "|%-6s"    , $a_ref->[10]; }  #BURST TYPE                 $a_ref->[ 8]
           if ( $a_ref->[11] =~ m/[-]/){ printf $parh "| %7s "   , $a_ref->[11];    #BURST SIZE                 $a_ref->[ 9]
           } else {                      printf $parh "| %4s    ", $a_ref->[11]; }  #BURST SIZE                 $a_ref->[ 9]
           printf $parh "|%2s "        , $a_ref->[12];                              #HPROT                      $a_ref->[10]
           if ( $a_ref->[13] =~ m/[-]/){ printf $parh "| %s |\n" , $a_ref->[13];    #HSEL                       $a_ref->[11]
           } else {                      printf $parh "|%12s|\n" , $a_ref->[13]; }  #HSEL                       $a_ref->[11]
    } else {
           #
           # Debug code, catch the failure and parse again
           #
           printf $parh "   Skipped : %s\n", $row;
           $row =~ m{^[|]\s+(\d+)[ ](ns|ps)
                      [|]\s+(\d+)[ ](ns|ps)
                      [|]([A-Z-]+)          [ ]+
                      [|]\s([A-F0-9]{8})    [ ]+
                      [|]\s([0-9/ ?-]{5})   [ ]   # Column  5: Beat# 5 characters [? /0-9]
                      [|]\s+([0-9-?]+)      [ ]
                      [|]\s([A-F0-9\-\.]{8})[ ]
                      [|]\s+([\-A-Z]+)      [ ]+
                      [|]\s*([-A-Z0-9]+)    [ ]*  # Column  9: Burst Type SINGLE, WRAP4, INCR8 .. WRAP16, ' ---- '
                      [|]\s+([0-9\-]+)      [ ]+  # Column 10: Burst Size, text string !! Not data
                      [|]\s([-A-F0-9]{1})   [ ]   # Column 11: HPROT, Hex number
                      [|]\s+([0-9\-]+)\s*   [|] 

                    }ixms;
           printf $parh "       \$1 : %s\n", $1;
           printf $parh "       \$2 : %s\n", $2;
           printf $parh "       \$3 : %s\n", $3;
           printf $parh "       \$4 : %s\n", $4;
           printf $parh "       \$5 : %s\n", $5;
           printf $parh "       \$6 : %s\n", $6;
           printf $parh "       \$7 : %s\n", $7;
           printf $parh "       \$8 : %s\n", $8;
           printf $parh "       \$9 : %s\n", $9;
           printf $parh "       \$10: %s\n", $10;
           printf $parh "       \$11: %s\n", $11;             
           printf $parh "       \$12: %s\n", $12;             
           printf $parh "       \$13: %s\n", $13;             
           printf $parh "       \$14: %s\n", $14;             
    }# tracefile parser
}#sub parse_body


sub build_command_obj {
    my ( $COL                           # input     column array with extracted values from tabel row
       , $buih ) = @_;                  #           file handle to building log

    state $first_cmd   = 1;             # Exception handling for first command transaction

    my %command;                        # Create new cmd transfer obj:186
    my $ptr_cur_cmd = \%command;        # Pointer to command object/transaction

    #=============================================================================================================
    #
    #   ----> ptr_fst_cmd           %AHB_hash
    #   ----> FIRST
    #
    #
    #
    #                                                               ----------|
    #                                                               |         |
    #                                                               |         V                                                                       ptr_lst_data
    #                                            prev  ^            |   | ptr_fst_data                                                              | ptr_pre_data
    #                                                  |            |   |                                                                           |
    #                                                  |            |   V                                                                           V  
    #                             -------------------------         |
    #   ----> ptr_pen_cmd         |  previous cmd object  |         |
    #   ----> ANTEPENULTIMATE     |-----------------------|         |
    #                             |                       |       --------------------       --------------------       --------------------       --------------------
    #                             |                       |       | prev             | <---- | prev             | <---- | prev             | <---- | prev             |
    #                             |                       |       |------------------|       |------------------|       |------------------|       |------------------|
    #                             |                       |       |                  |       |                  |       |                  |       |                  |
    #                             |-----------------------|       |                  |       |                  |       |                  |       |                  |
    #                             |               data    | ----> |                  |       |                  |       |                  |       |                  |
    #                             |-----------------------|       |             next | ----> |             next | ----> |             next | ----> |             next | ----> ptr_fst_data 
    #                             |                       |       |------------------|       |------------------|       |------------------|       |------------------|      !ptr_lst_data
    #                             |                       |
    #                             |-----------------------|     
    #                             |  next     cmd object  |
    #                             ------------------------- 
    #                                |
    #                                |
    #                                V  next
    #                                            prev  ^
    #                                                  |
    #                                                  |
    #                             -------------------------      
    #   ----> ptr_pre_cmd         |  previous cmd object  |   
    #   ----> PREVIOUS            |-----------------------|     
    #   ----> PENULTIMATE         |                       |
    #                             |                       |
    #                             |                       |
    #                             |                       |
    #                             |                       |
    #                             |-----------------------|       
    #                             |               data    | ---->  undefined
    #                             |-----------------------|       
    #                             |                       |
    #                             |                       |
    #                             |-----------------------|     
    #                             |  next     cmd object  |
    #                             ------------------------- 
    #                                |
    #                                |
    #                                V  next
    #                                            prev  ^
    #                                                  |
    #                                                  |
    #                             -------------------------      
    #   ----> ptr_cur_cmd         |  previous cmd object  |   
    #   ----> CURRENT             |-----------------------|     
    #   ----> LAST/ULTIMATE       |                       |
    #                             |                       |
    #                             |                       |
    #                             |                       |
    #                             |                       |
    #                             |-----------------------|       
    #                             |               data    | ---->  undefined 
    #                             |-----------------------|      
    #                             |                       |
    #                             |                       |
    #                             |-----------------------|     
    #                             |  next     cmd object  |
    #   ----> ptr_lst_cmd         ------------------------- 
    #                                |
    #                                |
    #                                V  next
    #                                ptr_fst_cmd
    #
    #=============================================================================================================
    $ptr_lst_cmd              = $ptr_cur_cmd;                   # No look ahead, current ptr is last ptr

    $command{assert}          = $COL->[ 0]; #$line[ 0];         # assertion  time / addr_assertion
    $command{complete}        = $COL->[ 2]; #$line[ 1];         # completion time / addr_sampling 
    $command{direction}       = $COL->[ 4]; #$line[ 2];         # direction  READ/WRITE  BUSY/DATA
    $command{addr}            = $COL->[ 5]; #$line[ 3];         # ADDRESS    aligned, unaligned
   #$command{beat_num}        NA        6                       # BEAT
    $command{burst_len}       = $COL->[ 7]; #$line[ 5];         # 1, 4, 8, 16, any >1
   #$command{data}            NA        8                       # DATA  strobed
   #$command{response}        NA        9                       # Slave response
    $command{burst_type}      = $COL->[10]; #$line[ 8];         # SINGLE,INCR,INCR4,WRAP4,INCR8,WRAP8,INCR16,WRAP16
    $command{burst_size}      = $COL->[11]; #$line[ 9];         # 1, 2 or 4 Byte
    $command{hport}           = $COL->[12]; #$line[10];         # HPROT protection   CACHE,BUFFER,PRIVILEGE,OPCODE/DATA
   #$command{slave}           = $COL->[13]; #$line[11];         # Slave index
   #
   #$command{data}            = undef;                          # A AHB command has no DATA transfers associated yet !!

    printf $buih  "%*s%s :: first command\n", 22, '', $first_cmd;

    if ( $first_cmd ) {
        $ptr_fst_cmd          = $ptr_cur_cmd;                   # Set entry point first       Command
        $ptr_pen_cmd          = $ptr_cur_cmd;                   # Set       point penultimate Command
        $ptr_prv_cmd          = $ptr_cur_cmd;                   # Set       point previous    Command
        $command{prev}        = $ptr_fst_cmd;                   # points to itself prev == curr
        $command{next}        = $ptr_fst_cmd;                   # 
        $first_cmd            = 0;                              # Update SM parse AHB tracker
    } else {                                                    # first command
        ${$ptr_prv_cmd}{next} = $ptr_lst_cmd;                   # Update previous cmd obj next reference
        #$command{next}       = $ptr_lst_cmd;                   # Referencing self not prefered Option
        $command{next}        = $ptr_fst_cmd;                   # Referencing circular to first pointer
        $command{prev}        = $ptr_prv_cmd;                   # Pointing back
        $ptr_pen_cmd          = $ptr_prv_cmd;                   # Update    point penultimate Command
        $ptr_prv_cmd          = $ptr_cur_cmd;                   # Update    point previous    Command
    }
    return $ptr_cur_cmd;                                        # Return pointer to current object
}#sub build_command_obj


sub build_data_obj{
    my ( $COL                                                   # Input     column array w/ parsed trace data
       , $buih ) = @_;                                          #           file handle to building log

    state $last_data = 0;                                       # After a last data, Need to create first data !!

    my %data_obj;                                               # Create new data transfer obj
    my $ptr_cur_dta = \%data_obj;                               # Pointer to data transfer obj

    #
    # $ptr_prv_cmd points to the LAST command/addr transfer, as it is the previous & current & last command !!
    #

    $data_obj{assert}         = $COL->[ 0]; #$line[0];          # assertion  time / data transfer assertion
    $data_obj{complete}       = $COL->[ 2]; #$line[1];          # completion time / data transfer completion
    $data_obj{phase}          = $COL->[ 4]; #$line[2];          # direction  READ/WRITE  phase   DATA/BUSY
    $data_obj{address}        = $COL->[ 5]; #$line[3];          # ADDRESS updated, select SLAVE, data strobe, warp
    $data_obj{beat_num}       = $COL->[ 6]; #$line[4];          # BEAT
   #$data_obj{burst_len}      NA        7                       # 1, 4, 8, 16, any >1
    $data_obj{data}           = $COL->[ 8]; #$line[6];          # DATA ( 1, 2, 4) Byte strobed via address
    $data_obj{response}       = $COL->[ 9]; #$line[7];          # Slave response OKAY/ERROR
   #$data_obj{burst_type}     NA       10                       # SINGLE,INCR,INCR4,WRAP4,INCR8,WRAP8,INCR16,WRAP16
   #$data_obj{burst_size}     NA       11                       # 1, 2 or 4 Byte
   #$data_obj{protection}     NA       12                       # HPROT protection   CACHE,BUFFER,PRIVILEGE,OPCODE/DATA
   #$data_obj{slave_index}    NA       13                       # Slave index

    #
    # The problem of concurrent DATA PHASE w/ ADDR PHASE of next command, creates TWO instead of ONE OT transactions
    # this leads to an incomplete occupied state machine, to identify the data phase as either LAST or FIRST transfer
    #
    
    #if ( ${$ptr_prv_cmd}{data} eq undef ) {
    if ( !defined ${$ptr_prv_cmd}{data} ) {
         printf $buih  "%*s::             AHB address transfer phase detected\n", 22, '';
         if ( $data_obj{assert} == ${$ptr_prv_cmd}{assert} ) {
              #if ( !defined ${${$ptr_prv_cmd}{prev}}{data}  ) {
              if ( !defined ${$ptr_pen_cmd}{data} ) {    
                   printf $buih  "%*s:: penultimate AHB address transfer has no FIRST data phase detected\n", 22, '';

                   printf $buih  "%*s:: sequential  AHB data    transfer phase detected FIRST\n", 22, '';
                   printf $buih " %*sDATA transfer assertion time : %8s ns\n", 24, '',$data_obj{assert};
                   printf $buih " %*sADDR transfer assertion time : %8s ns\n", 24, '',${$ptr_pen_cmd}{assert};
                   ${$ptr_pen_cmd}{data}                 # update penultimate & previous last command pointer to
                   = $ptr_cur_dta;                       # first/current data transaction
           
                   $ptr_fst_dta                          # Store  first data pointer to
                   = $ptr_cur_dta;                       # current/first data transaction
           
                   $data_obj{prev}                       # update previous data object pointer 
                   = $ptr_fst_dta;                       # points to itself, first data object/transaction
           #       = undef;                                       # undefined NO previous data obj
           #       = $ptr_lst_cmd;                                # points to the previous command
           
                   $data_obj{next}                       # Initial pointer to next     data object
                   = $ptr_fst_dta;                       # points circular to first    data object
                                                         # to be  updated  w/ next     data object
           
                   $data_obj{last}                       # Initial pointer to last     data object/transfer
                   = $ptr_cur_dta;                       # with               current  data object
                     
                   $ptr_prv_dta                          # Store  pointer  to previous data object 
                   = $ptr_fst_dta;                       # points          to current  data object
              } else {
                   printf $buih  "%*s:: penultimate AHB address transfer had    FIRST data phase detected\n", 22, '';
                   
                   #
                   # $ptr_prv_dta, $ptr_lst_dta, $ptr_fst_dta are not updated - thus behave correctly sequential
                   # still pointing to the sequential DATA transfers of the second last/antepenultimate  AHB CMD
                   #

                   ${$ptr_prv_dta}{next}                 # Update/overwrite previous   data object next_pointer
                   = $ptr_cur_dta;                       # with   pointer to current   data object/transaction

                   $data_obj{next}                       # Initial pointer to next     data object next_pointer
                   = $ptr_fst_dta;                       # points circular to first    data object/transaction

                   $data_obj{prev}                       # Store   pointer to previous data object/transaction
                   = $ptr_prv_dta;                       # points          to previous data object/transaction

                   $ptr_prv_dta                          # Update  pointer to previous data object/transaction
                   = $ptr_cur_dta;                       # with               current  data object/transaction
                   
                   $ptr_lst_dta                          # Update  pointer to last     data object/transaction
                   = $ptr_cur_dta;                       # with               current  data object/transaction

                   ${$ptr_fst_dta}{last}                 # Update  first data object   last_(transaction)_pointer
                   = $ptr_lst_dta;                       # with    pointer to last     data object/transaction
              }
         } else {
              printf $buih  "%*s:: sequential  AHB data    transfer phase detected FIRST\n", 22, '';
              printf $buih " %*sDATA transfer assertion time : %8s ns\n", 24, '',$data_obj{assert};
              printf $buih " %*sADDR transfer assertion time : %8s ns\n", 24, '',${$ptr_prv_cmd}{assert};
              ${$ptr_prv_cmd}{data}                 # update previous&last command pointer to
              = $ptr_cur_dta;                       # first/current data transaction
      
              $ptr_fst_dta                          # Store  first data pointer to
              = $ptr_cur_dta;                       # current/first data transaction
      
              $data_obj{prev}                       # update previous data object pointer 
              = $ptr_fst_dta;                       # points to itself, first data object/transaction
      #       = undef;                                       # undefined NO previous data obj
      #       = $ptr_lst_cmd;                                # points to the previous command
      
              $data_obj{next}                       # Initial pointer to next     data object
              = $ptr_fst_dta;                       # points circular to first    data object
                                                    # to be  updated  w/ next     data object
      
              $data_obj{last}                       # Initial pointer to last     data object/transfer
              = $ptr_cur_dta;                       # with               current  data object
                
              $ptr_prv_dta                          # Store  pointer  to previous data object 
              = $ptr_fst_dta;                       # points          to current  data object
         }# Insert FIRST
    } else {
         printf $buih  "%*s:: sequential AHB data    transfer phase detected\n", 22, '';
         ${$ptr_prv_dta}{next}                      # Update/overwrite previous   data object next_pointer
         = $ptr_cur_dta;                            # with   pointer to current   data object/transaction

         $data_obj{next}                            # Initial pointer to next     data object next_pointer
         = $ptr_fst_dta;                            # points circular to first    data object/transaction

         $data_obj{prev}                            # Store   pointer to previous data object/transaction
         = $ptr_prv_dta;                            # points          to previous data object/transaction

         $ptr_prv_dta                               # Update  pointer to previous data object/transaction
         = $ptr_cur_dta;                            # with               current  data object/transaction
         
         $ptr_lst_dta                               # Update  pointer to last     data object/transaction
         = $ptr_cur_dta;                            # with               current  data object/transaction

         ${$ptr_fst_dta}{last}                      # Update  first data object   last_(transaction)_pointer
         = $ptr_lst_dta;                            # with    pointer to last     data object/transaction
    }
}#sub build_data_obj


sub initialize_latency_analysis {
    my ($a_ref) = @_;                                                 # Reference to hash
    
   #printf        " ... initialzing latency analysis\n";
   #printf $proh  " ... initialzing latency analysis\n";

    my $ridiculous = 1000000;

    #
    # This set was used for calculation including ADDR phase
    #

    ${$a_ref}{ALL}{minimum}     = $ridiculous;
    ${$a_ref}{ALL}{average}     = 0;
    ${$a_ref}{ALL}{maximum}     = 0;
    ${$a_ref}{ALL}{number}      = 0;

    ${$a_ref}{READ}{minimum}    = $ridiculous;
    ${$a_ref}{READ}{average}    = 0;
    ${$a_ref}{READ}{maximum}    = 0;
    ${$a_ref}{READ}{number}     = 0;

    ${$a_ref}{WRITE}{minimum}   = $ridiculous;
    ${$a_ref}{WRITE}{average}   = 0;
    ${$a_ref}{WRITE}{maximum}   = 0;
    ${$a_ref}{WRITE}{number}    = 0;

    #
    # First data transfer 
    #

    ${$a_ref}{1}{ALL}{minimum}  = $ridiculous;
    ${$a_ref}{1}{ALL}{average}  = 0;
    ${$a_ref}{1}{ALL}{maximum}  = 0;
    ${$a_ref}{1}{ALL}{number}   = 0;
    ${$a_ref}{1}{ALL}{total}    = 0;

    ${$a_ref}{1}{READ}{minimum} = $ridiculous;
    ${$a_ref}{1}{READ}{average} = 0;
    ${$a_ref}{1}{READ}{maximum} = 0;
    ${$a_ref}{1}{READ}{number}  = 0;
    ${$a_ref}{1}{READ}{total}   = 0;

    ${$a_ref}{1}{WRITE}{minimum}= $ridiculous;
    ${$a_ref}{1}{WRITE}{average}= 0;
    ${$a_ref}{1}{WRITE}{maximum}= 0;
    ${$a_ref}{1}{WRITE}{number} = 0;
    ${$a_ref}{1}{WRITE}{total}  = 0;

    # Last data transfer, complete burst

    ${$a_ref}{L}{ALL}{minimum}  = $ridiculous;
    ${$a_ref}{L}{ALL}{average}  = 0;
    ${$a_ref}{L}{ALL}{maximum}  = 0;
    ${$a_ref}{L}{ALL}{number}   = 0;
    ${$a_ref}{L}{ALL}{total}    = 0;

    ${$a_ref}{L}{READ}{minimum} = $ridiculous;
    ${$a_ref}{L}{READ}{average} = 0;
    ${$a_ref}{L}{READ}{maximum} = 0;
    ${$a_ref}{L}{READ}{number}  = 0;
    ${$a_ref}{L}{READ}{total}   = 0;

    ${$a_ref}{L}{WRITE}{minimum}= $ridiculous;
    ${$a_ref}{L}{WRITE}{average}= 0;
    ${$a_ref}{L}{WRITE}{maximum}= 0;
    ${$a_ref}{L}{WRITE}{number} = 0;
    ${$a_ref}{L}{WRITE}{total}  = 0;

    printf "\n";
    printf $proh " ... initialzing latency analysis done !!\n";
}#sub initialize_latency_analysis


sub   initialize_transaction_analysis {
      my ( $a_ref ) = @_;                           # Reference to hash -->  $ahb_anal ysis

      my @_list     = ( "SINGLE", "INCR", "INCR4", "INCR8", "INCR16", "WRAP4", "WRAP8", "WRAP16", "total" );
      my @_dirs     = ( "READ", "WRITE" );          # direction
      my @_size     = ( 1, 2, 4 );                  # byte
    
      foreach my $size (@_size) {
          foreach my $dir (@_dirs) {
              foreach my $trans (@_list) {
                  ${$a_ref}{transaction}{$trans}              = 0;
                  ${$a_ref}{transaction}{$dir}{$trans}        = 0;
                  ${$a_ref}{transaction}{$size}{$dir}{$trans} = 0;
              }# trans
          }# dirs
      }# size
      printf $proh " ... initialzing transaction analysis done !!\n";
}#sub initialize_transaction_analysis


sub   initialize_payload_analysis {
      my (  $trace_header_ref                                                   # Trace   information from trace file h
         ,  $ptr_ref                                                            # Pointer information into trace list
         ,  $opts_ref     ) = @_;                                               # Command line options

      my $transaction       = 0;
      my $totalbeat         = 0;
      my $data_beat         = 0;
      my $busy_beat         = 0;
      my $total_payload     = 0;
      my $write_payload     = 0;
      my $read_payload      = 0;

      my $stop_ptr          =   ${${$ptr_ref}{first}};                          # Set buffer stop pointer to the FIRST  pointer of Transfer List
      my $ptr_cur_cmd       =   ${${$ptr_ref}{first}};                          # Set iterate     pointer to the FIRST  pointer of Transfer List

      my $cycle             = ${$trace_header_ref}{period};                     # (float)
      my $tb                = ${$trace_header_ref}{timebase};                   # =  $6; # (ns|ps)
      my $frequency         = ${$trace_header_ref}{frequency};                  # (float)
      my $fb                = ${$trace_header_ref}{freqbase};                   # (MHz|GHz)
      my $logfile           = ${$opts_ref}{payload};                            # logfile name
      my $errlog            = ${$opts_ref}{errlog};

      printf $proh  " ... initializing payload analysis\n";
     
      printf $proh  "     opening    payload log %s\n", $logfile;
      printf $proh  "     opening    error   log %s\n", $errlog;
      open (my $payh, ">$logfile")  || die " Can not create log $logfile";
      open (my $errh, ">$errlog")   || die " Can not create log $errlog";       # Report errors trace file formats

      printf $errh  " %s\n"     , '='x80;
      printf $errh  " Tracefile : %s\n"             , $Trace{tracefile};        
      printf $errh  " Script    : %s %s\n"          , $0, $VERSION;             #  0  1, 2,    3,   4,    5,    6,    7,     8
      printf $errh  " Date      : %4s-%02s-%02s\n"  , 1900+$year,$mon,$cday;    # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf $errh  " Time      : %4s:%02s:%02s\n"  , $h, $m,$s;                # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf $errh  " Cycle     : %10s %s\n"        , $cycle, $tb;              # Header timebase information
      printf $errh  " Frequency : %10s %s\n",       , $frequency, $fb;          # Header frequency information
      printf $errh  " %s\n"     , '='x80;

      printf $payh  " %s\n"     , '='x80;
      printf $payh  " Tracefile : %s\n"             , $Trace{tracefile};
      printf $payh  " Logfile   : %s\n"             , $logfile; 
      printf $payh  " Script    : %s %s\n"          , $0, $VERSION;             #  0  1, 2,    3,   4,    5,    6,    7,     8
      printf $payh  " Date      : %4s-%02s-%02s\n"  , 1900+$year,$mon,$cday;    # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf $payh  " Time      : %4s:%02s:%02s\n"  , $h, $m,$s;                # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf $payh  " Cycle     : %10s %s\n"        , $cycle, $tb;              # Header timebase information
      printf $payh  " Frequency : %10s %s\n",       , $frequency, $fb;          # Header frequency information
      printf $payh  " %s\n"     , '='x80;

      do {
          $transaction++;                                                       # For   all transactions
          $ptr_cur_dta = ${$ptr_cur_cmd}{data};                                 # Set   pointer for data transfer
          $ptr_fst_dta = ${$ptr_cur_dta}{prev};
          $ptr_lst_dta = ${$ptr_cur_dta}{last};
          $totalbeat   = 0;                                                     # Start count fresh for each transaction
          $data_beat   = 0;
          $busy_beat   = 0;

          printf $payh "%*s %s %10s\n"  ,12, '', 'Transaction   :', $transaction;
          printf $payh "%*s %s %10s\n"  ,12, '', 'Direction     :', ${$ptr_cur_cmd}{direction};
          printf $payh "%*s %s %10s\n"  ,12, '', 'Burst Type    :', ${$ptr_cur_cmd}{burst_type};

          printf $errh "%*s %s %10s\n"  ,12, '', 'Transaction   :', $transaction;
          printf $errh "%*s %s %10s\n"  ,12, '', 'Burst Type    :', ${$ptr_cur_cmd}{burst_type};

          do {
              if ( ${$ptr_cur_dta}{phase} =~ m/DATA/ ) {                        # DATA, BUSY phase
                  $totalbeat++;                                                 # ONLY data transfer count                      
                  $data_beat++;
                  printf $payh "%*s %s %2s of %2s :: %s" ,30,'','transfer  '   
                               ,$data_beat,$totalbeat,${$ptr_cur_dta}{phase};
              }
              if ( ${$ptr_cur_dta}{phase} =~ m/BUSY/ ) {
                   $busy_beat++;                                                # A wait state is no BEAT, it is an extention
                   printf $payh "%*s %s %2s of %2s :: %s" ,30,'','wait state'   
                                ,$busy_beat,$totalbeat,${$ptr_cur_dta}{phase};
              }
              printf $payh " :: %s %s\n" ,'beat    ',${$ptr_cur_dta}{beat_num};
              my ($beat,$length) = split /\//, ${$ptr_cur_dta}{beat_num};
              if ( $beat != $data_beat ) {
                   printf $errh "%*s %s %2s vs %2s :: %s\n",30,'','Error Beat'
                                ,$data_beat,${$ptr_cur_dta}{beat_num}, 'reported';
              }#report trace error

              $ptr_cur_dta = ${$ptr_cur_dta}{next};         # circular list points to the beginning
          }until ($ptr_cur_dta == $ptr_fst_dta);            # If first is the last&only pointer, then the next is the first as well
 
          ${$ptr_cur_cmd}{transaction} = $transaction;                                                  # Ordinal transaction number, for xref
          ${$ptr_cur_cmd}{burstlength} = $totalbeat;                                                    # Last beat/data transfer/burst length 
          ${$ptr_cur_cmd}{payload}     = $totalbeat * ${$ptr_cur_cmd}{burst_size};                      # data transfered in burst
          $total_payload              += $totalbeat * ${$ptr_cur_cmd}{burst_size};
          $write_payload              += $totalbeat * ${$ptr_cur_cmd}{burst_size} if ( ${$ptr_cur_cmd}{direction} =~ m/WR/ );
          $read_payload               += $totalbeat * ${$ptr_cur_cmd}{burst_size} if ( ${$ptr_cur_cmd}{direction} =~ m/RD/ );
          
          printf $payh "%*s %s %10s byte/beat\n",12, '', 'Burst Size    :', ${$ptr_cur_cmd}{burst_size};
          printf $payh "%*s %s %10s beat\n"     ,12, '', 'Burst Length  :', ${$ptr_cur_cmd}{burstlength};
          printf $payh "%*s %s %10s byte\n"     ,12, '', 'Burst Payload :', ${$ptr_cur_cmd}{payload    };
          printf $payh "\n";
          printf $errh "\n";
          
          $ptr_cur_cmd = ${$ptr_cur_cmd}{next};             # Progress to next transaction/transfer AHB command
      } until ($ptr_cur_cmd == $stop_ptr );                 # Iterate  over entire transaction list

      printf $payh  "\n";
      printf $payh  "%*s %s %10s byte\n" ,12, '', 'Payload Total:', $total_payload;
      printf $payh  "%*s %s %10s byte\n" ,12, '', 'Payload Write:', $write_payload;
      printf $payh  "%*s %s %10s byte\n" ,12, '', 'Payload Read :', $read_payload;
      close( $payh );
      close( $errh );
      printf $proh  "     closing    error   log %s\n", $errlog;
      printf $proh  "     closing    payload log %s\n", $logfile;
      printf $proh  " ... initializing payload done\n";
      printf $proh  "\n";
}#sub initialize_payload_analysis

#
#     Analysis of transfers on a transaction by transfer basis
#     Each transaction is analyzed standalone, ADDR transfer concealment is not considered
#     Results are transaction based not accumulated
#

sub   transfer_analysis {
      my (  $trace_header_ref                   # input     Trace   information from trace file header
         ,  $ptr_ref                            #           Pointer information into trace list
         ,  $opts_ref                           #           Command line options
         ,  $transfer_ref      ) = @_;          # output    Transfer analysis

      my $logfile     = ${$opts_ref}{transfer};
      my $cycle       = ${$trace_header_ref}{period};       # (float)
      my $tb          = ${$trace_header_ref}{timebase};     # =  $6; # (ns|ps)
      my $frequency   = ${$trace_header_ref}{frequency};    # (float)
      my $fb          = ${$trace_header_ref}{freqbase};     # (MHz|GHz)
      my $transaction = 0;
      my $beat        = 0;

      printf  $proh  "\n";
      printf  $proh  " ... transfer analysis\n";
      printf  $proh  "     opening    transfer log %s\n"  ,  $logfile;
      open(my $trah, ">$logfile")|| die " Can not create log $logfile";         # Are the bus transfers accounted for ? Mendatory
      printf  $trah  " %s\n"     , '='x80;
      printf  $trah  " Tracefile : %s\n"             , $Trace{tracefile};
      printf  $trah  " Logfile   : %s\n"             , $logfile; 
      printf  $trah  " Script    : %s %s\n"          , $0, $VERSION;            #  0  1, 2,    3,   4,    5,    6,    7,     8
      printf  $trah  " Date      : %4s-%02s-%02s\n"  , 1900+$year,$mon,$cday;   # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf  $trah  " Time      : %4s:%02s:%02s\n"  , $h, $m,$s;               # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf  $trah  " Cycle     : %10s %s\n"        , $cycle, $tb;             # Header timebase information
      printf  $trah  " Frequency : %10s %s\n",       , $frequency, $fb;         # Header frequency information
      printf  $trah  " %s\n"     , '='x80;
      
      my $ptr_cur_cmd               =   ${${$ptr_ref}{first}};
      my $buffer_stop               =   ${${$ptr_ref}{first}};
      my $last_transfer_stop        = ${${${$ptr_ref}{first}}}{assert};         # Wrong initialization, for calculation
      my $previous_transfer_stop    = ${${${$ptr_ref}{first}}}{assert};
      my $IDLE_duration             = 0;                                        # Checks and balances 
      my $ADDR_duration             = 0;                                        # Checks and balances
      my $DATA_duration             = 0;                                        # Checks and balances
      my $TIME_duration             = 0;                                        # Checks and balances
      my $TIME_START                = ${$ptr_cur_cmd}{assert};                  # Start of trace window, assert first transfer
      do {
          $transaction++;
          $beat = 0;
          # 
          # IDLE transfer is implicite in trace file and zero in back to back transactions
          # ADDR transfer might be concealed behind DATA transfers
          #
          # previous_transfer_stop   <  ${$ptr_cur_cmd}{assert} ==> IDLE not ZERO
          #                                                         ADDR not ZERO, Not consealed
          #
          # previous_transfer_stop  ==  ${$ptr_cur_cmd}{assert} ==> IDLE  == ZER0
          #                                                         ADDR not ZERO, Not consealed
          # previous_transfer_stop  ==  ${$ptr_cur_cmd}{complete} 
          # previous_transfer_stop   >  ${$ptr_cur_cmd}{assert} ==> IDLE  == ZERO
          #                                                         ADDR  == ZERO,     consealed behind DATA
          #                                                         ADDR  is consealed/hidden behind previous DATA
          #
          
          if    ( ${$ptr_cur_cmd}{assert}  > $previous_transfer_stop ) {
                  ${$transfer_ref}{$transaction}{ADDR}{concealed}       = 'NOT';
                  ${$transfer_ref}{$transaction}{IDLE}{transferstart}   = $previous_transfer_stop;
                  ${$transfer_ref}{$transaction}{IDLE}{transferstop}    = ${$ptr_cur_cmd}{assert};
          }elsif( ${$ptr_cur_cmd}{assert} == $previous_transfer_stop ) {
                  ${$transfer_ref}{$transaction}{ADDR}{concealed}       = 'NOT';
                  ${$transfer_ref}{$transaction}{IDLE}{transferstart}   = $previous_transfer_stop;
                  ${$transfer_ref}{$transaction}{IDLE}{transferstop}    = $previous_transfer_stop;
          }elsif( ${$ptr_cur_cmd}{assert}  < $previous_transfer_stop ) {
                  ${$transfer_ref}{$transaction}{ADDR}{concealed}       = 'YES';
                  ${$transfer_ref}{$transaction}{IDLE}{transferstart}   = ${$ptr_cur_cmd}{assert};
                  ${$transfer_ref}{$transaction}{IDLE}{transferstop}    = ${$ptr_cur_cmd}{assert};
          }
          ${$transfer_ref}{$transaction}{ADDR}{transferstart}   = ${$ptr_cur_cmd}{assert};
          ${$transfer_ref}{$transaction}{ADDR}{transferstop }   = ${$ptr_cur_cmd}{complete};
          ${$transfer_ref}{$transaction}{IDLE}{duration}        = ${$transfer_ref}{$transaction}{IDLE}{transferstop}     
                                                                - ${$transfer_ref}{$transaction}{IDLE}{transferstart};
          ${$transfer_ref}{$transaction}{ADDR}{duration}        = ${$transfer_ref}{$transaction}{ADDR}{transferstop} 
                                                                - ${$transfer_ref}{$transaction}{ADDR}{transferstart};

          $previous_transfer_stop   = ${$ptr_cur_cmd}{complete};
          $ptr_cur_dta              = ${$ptr_cur_cmd}{data};                                     # Set pointer to              data transfer also the first
          $ptr_fst_dta              = ${$ptr_cur_dta}{prev};                                     # Initialize pointer to first data transfer
          $ptr_lst_dta              = ${$ptr_cur_dta}{last};                                     # Initialize pointer to last  data transfer

          ${$ptr_cur_cmd}{AddrComp} = ${$ptr_cur_cmd}{complete} - ${$ptr_cur_cmd}{assert};

          #
          # Transfer analysis   - Each AHB transaction can has WAIT states, aka BUSY transfers
          #
          
          printf $trah "%*s %s %10s\n"      , 8, '', 'Transaction:', $transaction;                                       
          printf $trah "%*s %s %10s %s %s\n", 8, '', 'IdleTransfer', ${$transfer_ref}{$transaction}{IDLE}{duration}, $tb
                                                                   ,(${$transfer_ref}{$transaction}{IDLE}{duration} == 0)
                                                                   ? 'Back2Back'
                                                                   : 'IDLE';
          printf $trah "%*s %s %10s %s %s\n", 8, '', 'AddrTransfer', ${$transfer_ref}{$transaction}{ADDR}{duration}, $tb
                                                                   ,(${$transfer_ref}{$transaction}{ADDR}{concealed} =~ m/NOT/)
                                                                   ? 'Transfer visible'
                                                                   : 'Transfer consealed';
          ${$transfer_ref}{$transaction}{BUSY}{duration}        = 0; # Implicite WAIT states, accounted explicite, initialized to ZERO
          ${$transfer_ref}{$transaction}{BUSY}{total}{duration} = 0; # Initialize WAIT states as ZERO
          do {
              #
              # The wait state or BUSY transfer comes before the DATA transfer complete
              #
              
              if ( ${$ptr_cur_dta}{phase} =~ m/BUSY/ ) {
                   my $wait_state = ${$ptr_cur_dta}{complete} - ${$ptr_cur_dta}{assert};                        # The trace protocol allows 1 or more WAIT state
                                                                                                                # being inserted, trace reports transfers not clock cycle
                   ${$transfer_ref}{$transaction}{BUSY}{$beat+1}{duration}  = $wait_state;                      # The wait state comes before the DATA transfer,
                   ${$transfer_ref}{$transaction}{BUSY}{total}{duration}   += $wait_state;                      # thus the wait state is associate w/ next beat
              }# BUSY beats, accounting for one or more WAIT states

              #
              # Only DATA transfers are beats, Trace protocol inserts/accounts expletice for WAIT states as BUSY cycles
              #

              if ( ${$ptr_cur_dta}{phase} =~ m/DATA/ ) {
                   $beat++;                                                                                     # Update data transfer beat count
                   #
                   # The first data transfer starts with the end of the ADDR transfer, 
                   # the first beat could be a BUSY transfer
                   #
                   if ( $previous_transfer_stop < ${$ptr_cur_dta}{assert} ) {                                   # There must have been a WAIT state
                        ${$transfer_ref}{$transaction}{DATA}{$beat}{transferstart} = $previous_transfer_stop;   # Trace protocol counts BUSY cycle, blurs beat count
                   } else {
                        ${$transfer_ref}{$transaction}{DATA}{$beat}{transferstart} = ${$ptr_cur_dta}{assert};   # extract transfer start
                   }# determin DATA transfer start with WAIT states
                   ${$transfer_ref}{$transaction}{DATA}{$beat}{transferstop}       = ${$ptr_cur_dta}{complete}; # extract transfer stop
                   ${$transfer_ref}{$transaction}{DATA}{$beat}{duration} = ${$transfer_ref}{$transaction}{DATA}{$beat}{transferstop }
                                                                         - ${$transfer_ref}{$transaction}{DATA}{$beat}{transferstart};

                   $previous_transfer_stop  = ${$ptr_cur_dta}{complete};                                        # Remember transaction completion Previous also Last
              }# DATA beats                                                                                     # Last transfer must be DATA transfer

              printf $trah "%*s %s %s :: %s", 28, '', 'beat    ', $beat, ${$ptr_cur_dta}{beat_num};
              printf $trah "%19s %s\n"                          , ${$ptr_cur_dta}{complete} - ${$ptr_cur_dta}{assert}, $tb;
              printf $trah "%*s %s %s %s\n" , 50, '', 'complete', ${$ptr_cur_dta}{complete}, $tb;
              printf $trah "%*s %s %s %s\n" , 50, '', 'assert  ', ${$ptr_cur_dta}{assert}  , $tb;
              $ptr_cur_dta = ${$ptr_cur_dta}{next};                                                             # circular list points to the beginning
          }until ($ptr_cur_dta == $ptr_fst_dta);                                                                # If first is the last&only pointer,
                                                                                                                # then the next is the first as well
          ${$transfer_ref}{$transaction}{ADDR}{length}          = $beat;                                        # Record the beat count of transaction, burst lenght
          ${$transfer_ref}{$transaction}{DATA}{total}{duration} = ${$transfer_ref}{$transaction}{DATA}{$beat}{transferstop }
                                                                - ${$transfer_ref}{$transaction}{ADDR}{transferstop };
          $last_transfer_stop                                   = ${$transfer_ref}{$transaction}{DATA}{$beat}{transferstop};
          printf $trah "%*s %s %10s %s\n", 8, '', 'BusyTransfer', ${$transfer_ref}{$transaction}{BUSY}{duration}, $tb;
          printf $trah "\n";

          #
          # For checks and balances, the total time visible on the BFM trace, should match the total trace window
          #
          
             $IDLE_duration                     
          += ${$transfer_ref}{$transaction}{IDLE}{duration};
          if ( ${$transfer_ref}{$transaction}{ADDR}{concealed} =~ m/NOT/) {
                  $ADDR_duration                
               += ${$transfer_ref}{$transaction}{ADDR}{duration};
          }# if ADDR transfer is visible and not concealed
             $DATA_duration                     
          += ${$transfer_ref}{$transaction}{DATA}{total}{duration};

          $ptr_cur_cmd = ${$ptr_cur_cmd}{next};                 # Iterate to the next transaction/transfer AHB command
      } until ($ptr_cur_cmd == $ptr_fst_cmd );#

      $TIME_duration  = $previous_transfer_stop - $TIME_START;  # Trace window period

      printf $trah "\n";
      printf $trah "%*s %s %10s\n"                 , 8, '', 'Total   IDLE :', $IDLE_duration;
      printf $trah "%*s %s %10s\n"                 , 8, '', 'Visibal ADDR :', $ADDR_duration;
      printf $trah "%*s %s %10s\n"                 , 8, '', 'Visibal DATA :', $DATA_duration;
      printf $trah "%*s %s %10s\n"                 , 8, '', 'Trace Window :', $TIME_duration;
      close( $trah );
      printf $proh  "     closing    transfer log %s\n", $logfile;
      printf $proh  " ... transfer analysis done\n";
      printf $proh "\n";
}#sub initialize_transfer_analysis



#
# Latency analysis spans multiple transfers, not a single transfer
#

sub   latency_analysis{
      my (  $trace_header_ref                                                   # input     Trace   information from trace file header
         ,  $ptr_ref                                                            #           Pointer information into transfer list
         ,  $opts_ref                                                           #           Command line options
         ,  $transfer_ref                                                       #           Transfer analysis
         ,  $latency_ref      ) = @_;                                           # output    Latency  analysis, %ahb_latency_new

      my $logfile     =             ${$opts_ref}{latency};
      my $cycle       =     ${$trace_header_ref}{period};       # (float)
      my $tb          =     ${$trace_header_ref}{timebase};     # =  $6; # (ns|ps)
      my $frequency   =     ${$trace_header_ref}{frequency};    # (float)
      my $fb          =     ${$trace_header_ref}{freqbase};     # (MHz|GHz)
      my $ptr_cur_cmd =   ${${$ptr_ref}{start}}; 
      my $buffer_stop =   ${${$ptr_ref}{stop}};  
      my $transaction = ${${${$ptr_ref}{start}}}{transaction};
     #my $ptr_cur_cmd =   ${${$ptr_ref}{first}};
     #my $buffer_stop =   ${${$ptr_ref}{first}};

      my $duration;                                         # duration of each DATA transfer

      printf  $proh  " ... latency    analysis new\n";
      printf  $proh  "     opening    latency log %s\n"   ,  $logfile;
      open(my $lath, ">$logfile")|| die " Can not create log $logfile";         # Are the bus transfers accounted for ? Mendatory

      printf  $lath  " %s\n"       , '='x80;
      printf  $lath  " Tracefile   : %s\n"           , $Trace{tracefile};
      printf  $lath  " Synopsis    : %s\n"           , 'Latency Analysis';
      printf  $lath  " Script      : %s %s\n"        , $0, $VERSION;              #  0  1, 2,    3,   4,    5,    6,    7,     8
      printf  $lath  " Date        : %4s-%02s-%02s\n", 1900+$year,$mon,$cday;     # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf  $lath  " Time        : %4s:%02s:%02s\n", $h, $m,$s;                 # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf  $lath  " Cycle       : %10s %s\n"      , $cycle, $tb;               # Header timebase information
      printf  $lath  " Frequency   : %10s %s\n"      , $frequency, $fb;           # Header frequency information
      printf  $lath  " Start       : %10s %s\n"      , ${${${$ptr_ref}{start}}}{assert}, $tb;
      printf  $lath  " Stop        : %10s %s\n"      , ${${${$ptr_ref}{stop}}}{assert} , $tb;
      printf  $lath  " %s\n"       , '='x80;
      printf  $lath  "\n";
      printf  $lath  "START pointer %s\n",   ${${$ptr_ref}{start}};
      printf  $lath  "Transaction#  %s\n", ${${${$ptr_ref}{start}}}{transaction};
      printf  $lath  "Start time    %s\n", ${${${$ptr_ref}{start}}}{assert};
      printf  $lath  "\n";
      printf  $lath  "STOP  pointer %s\n",   ${${$ptr_ref}{stop}};
      printf  $lath  "Transaction#  %s\n", ${${${$ptr_ref}{stop}}}{transaction};
      printf  $lath  "Stop time     %s\n", ${${${$ptr_ref}{stop}}}{assert};
      printf  $lath  "\n";
      do {
          $transaction++;
          my ($direction, $ctype) = split /-/ , ${$ptr_cur_cmd}{direction};
          my $phase               = ($ctype eq 'NONSEQ') ? 'ADDR' : 'IDLE';                       # NONSEQ, IDLE, SEQ/DATA, BUSY        Recoding  ADDR
          my $cmd                 = ($direction eq 'RD') ? 'READ' : 'WRITE';                      # Encode    READ vs RD; WRITE vs WR   Recoding  READ / WRITE

          my $L                   = ${$transfer_ref}{$transaction}{ADDR}{length};                 # LAST beat
          my $concealed           = ${$transfer_ref}{$transaction}{ADDR}{concealed};
          printf $lath "%*s %s %10s\n"      ,12, '', 'Transaction:', $transaction;
          printf $lath "%*s %s %10s\n"      ,12, '', 'Direction  :', $cmd;
          printf $lath "%*s %s %10s beat\n" ,12, '', 'BurstLength:', $L;
          printf $lath "%*s %s %10s\n"      ,12, '', 'Addr Phase :', ($concealed =~ m/NOT/ )
                                                                   ? 'visible'
                                                                   : 'concealed';
          #
          # Warning the latency considers only DATA transfers including WAIT states or BUSY cycles
          # No ADDR phase is considered in this analysis
          #

          my $i_duration                   = ${$transfer_ref}{$transaction}{IDLE}{duration};
          ${$latency_ref}{IDLE}{total}    += $i_duration;
          ${$latency_ref}{IDLE}{number}   += 1            if ($i_duration > 0);
          printf $lath "%*s %s %10s %s\n"   ,12, '', 'ADDRtransfr:',${$transfer_ref}{$transaction}{ADDR}{duration}         , $tb;
          # First DATA transfer latency
          my $f_duration                   = ${$transfer_ref}{$transaction}{DATA}{1}{duration};
          printf $lath "%*s %s %10s %s\n"   ,12, '', 'FirstData  :', $f_duration, $tb;
          # Last  DATA transfer latency    :   duration of all  DATA transfers combined/total burst
          my $l_duration                   = ${$transfer_ref}{$transaction}{DATA}{$L}{transferstop}                        # Not a single transfer analysis
                                           - ${$transfer_ref}{$transaction}{ADDR}{transferstop};
          printf $lath "%*s %s %10s %s\n"   ,12, '', 'AdrPhaseCmp:', ${$transfer_ref}{$transaction}{ADDR}{transferstart}   , $tb;
          printf $lath "%*s %s %10s %s\n"   ,12, '', 'LastDataCmp:', ${$transfer_ref}{$transaction}{DATA}{$L}{transferstop}, $tb;
          printf $lath "%*s %s %10s %s\n"   ,12, '', 'DtaPhaseCmp:', $l_duration, $tb;

          #
          # First data transfer 
          #

          ${$latency_ref}{1}{ALL}{total}     += $f_duration;                                                    # ALL READ & WRITE
          ${$latency_ref}{1}{ALL}{number}    += 1;                                                              # ALL transaction
          ${$latency_ref}{1}{ALL}{minimum}    = $f_duration if (${$latency_ref}{1}{ALL}{minimum} >= $f_duration); 
          ${$latency_ref}{1}{ALL}{maximum}    = $f_duration if (${$latency_ref}{1}{ALL}{maximum} <= $f_duration);

          ${$latency_ref}{1}{$cmd}{total}    += $f_duration;
          ${$latency_ref}{1}{$cmd}{number}   += 1;                                                              # ALL READ, ALL WRITE
          ${$latency_ref}{1}{$cmd}{minimum}   = $f_duration if (${$latency_ref}{1}{$cmd}{minimum} >= $f_duration); 
          ${$latency_ref}{1}{$cmd}{maximum}   = $f_duration if (${$latency_ref}{1}{$cmd}{maximum} <= $f_duration); 

          #
          # Last  data transfer 
          #
 
          ${$latency_ref}{L}{ALL}{total}    += $l_duration;
          ${$latency_ref}{L}{ALL}{number}   += 1;
          ${$latency_ref}{L}{ALL}{minimum}   = $l_duration if (${$latency_ref}{L}{ALL}{minimum} >= $l_duration); 
          ${$latency_ref}{L}{ALL}{maximum}   = $l_duration if (${$latency_ref}{L}{ALL}{maximum} <= $l_duration);


          ${$latency_ref}{L}{$cmd}{total}   += $l_duration;
          ${$latency_ref}{L}{$cmd}{number}  += 1;
          ${$latency_ref}{L}{$cmd}{minimum}  = $l_duration if (${$latency_ref}{L}{$cmd}{minimum} >= $l_duration);
          ${$latency_ref}{L}{$cmd}{maximum}  = $l_duration if (${$latency_ref}{L}{$cmd}{maximum} <= $l_duration);

          printf $lath "\n";     # Spacer
          $ptr_cur_cmd = ${$ptr_cur_cmd}{next};
      } until ( $ptr_cur_cmd == $buffer_stop );

      printf $lath "%*s %s %10s\n" ,12, '', 'ALL   1st Number:', ${$latency_ref}{1}{ALL  }{number};  
      printf $lath "%*s %s %10s\n" ,12, '', 'READ  1st Number:', ${$latency_ref}{1}{READ }{number};  
      printf $lath "%*s %s %10s\n" ,12, '', 'WRITE 1st Number:', ${$latency_ref}{1}{WRITE}{number}; 

      printf $lath "%*s %s %10s\n" ,12, '', 'READ  1st Total :', ${$latency_ref}{1}{READ }{total };  
      printf $lath "%*s %s %10s\n" ,12, '', 'WRITE 1st Total :', ${$latency_ref}{1}{WRITE}{total }; 
      
      printf $lath "%*s %s %10s\n" ,12, '', 'ALL   Lst Number:', ${$latency_ref}{L}{ALL  }{number};  
      printf $lath "%*s %s %10s\n" ,12, '', 'READ  Lst Number:', ${$latency_ref}{L}{READ }{number};  
      printf $lath "%*s %s %10s\n" ,12, '', 'WRITE Lst Number:', ${$latency_ref}{L}{WRITE}{number};
      
      ${$latency_ref}{1}{ALL  }{average} = ${$latency_ref}{1}{ALL  }{total} / ${$latency_ref}{1}{ALL  }{number};
      ${$latency_ref}{1}{READ }{average} = ${$latency_ref}{1}{READ }{total} / ${$latency_ref}{1}{READ }{number};
      ${$latency_ref}{1}{WRITE}{average} = ${$latency_ref}{1}{WRITE}{total} / ${$latency_ref}{1}{WRITE}{number};
          
      ${$latency_ref}{L}{ALL  }{average} = ${$latency_ref}{L}{ALL  }{total} / ${$latency_ref}{L}{ALL  }{number};
      ${$latency_ref}{L}{READ }{average} = ${$latency_ref}{L}{READ }{total} / ${$latency_ref}{L}{READ }{number};
      ${$latency_ref}{L}{WRITE}{average} = ${$latency_ref}{L}{WRITE}{total} / ${$latency_ref}{L}{WRITE}{number};
      #printf $lath "%*s %s %10s %s\n"   ,12, '', 'AdrPhaseCmp:', $tb;
      close( $lath );
      printf $proh  "     closing    latency log %s\n", $logfile;
      printf $proh  " ... latency    analysis new done\n";
}#sub latency_analysis


sub   bandwidth_analysis {
      my (  $trace_header_ref                                                       # input     Trace   information from trace file header
         ,  $ptr_ref                                                                #           Pointer information into transfer/trace list
         ,  $opts_ref                                                               #           Command line options
         ,  $transfer_ref                                                           #           Transfer analysis
         ,  $bandwidth_ref                                                          # output    Bandwidth analysis   %ahb_bandwidth_new
         ,  $transaction_ref    ) = @_;                                             #           Transaction analysis %ahb_transaction_new

      my $logfile     =         ${$opts_ref}{bandwidth};
      my $cycle       = ${$trace_header_ref}{period};                               # (float)
      my $tb          = ${$trace_header_ref}{timebase};                             # =  $6; # (ns|ps)
      my $frequency   = ${$trace_header_ref}{frequency};                            # (float)
      my $fb          = ${$trace_header_ref}{freqbase};                             # (MHz|GHz)
      my $ptr_cur_cmd = ${${$ptr_ref}{start}};                                      # Initialize starting point in transaction list 
      my $buffer_stop = ${${$ptr_ref}{stop}};  

      printf  $proh  "\n";
      printf  $proh  " ... bandwidth  analysis new\n";
      printf  $proh  "     opening    bandwidth log %s\n" ,  $logfile;
      open(my $banh, ">$logfile")|| die " Can not create log $logfile";             # Bandwidth log 

      printf  $banh  " %s\n"       , '='x80;
      printf  $banh  " Tracefile   : %s\n"           , $Trace{tracefile};
      printf  $banh  " Synopsis    : %s\n"           , 'Bandwidth Analysis';
      printf  $banh  " Script      : %s %s\n"        , $0, $VERSION;                #  0  1, 2,    3,   4,    5,    6,    7,     8
      printf  $banh  " Date        : %4s-%02s-%02s\n", 1900+$year,$mon,$cday;       # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf  $banh  " Time        : %4s:%02s:%02s\n", $h, $m,$s;                   # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf  $banh  " Cycle       : %10s %s\n"      , $cycle, $tb;                 # Header timebase information
      printf  $banh  " Frequency   : %10s %s\n"      , $frequency, $fb;             # Header frequency information
      printf  $banh  " Start       : %10s %s\n"      , ${${${$ptr_ref}{start}}}{assert}, $tb;
      printf  $banh  " Stop        : %10s %s\n"      , ${${${$ptr_ref}{stop}}}{assert} , $tb;
      printf  $banh  " %s\n"       , '='x80;
      printf  $banh  "\n";
      printf  $banh  "START pointer %s\n",   ${${$ptr_ref}{start}};
      printf  $banh  "Transaction#  %s\n", ${${${$ptr_ref}{start}}}{transaction};
      printf  $banh  "Start time    %s\n", ${${${$ptr_ref}{start}}}{assert};
      printf  $banh  "\n";
      printf  $banh  "STOP  pointer %s\n",   ${${$ptr_ref}{stop}};
      printf  $banh  "Transaction#  %s\n", ${${${$ptr_ref}{stop}}}{transaction};
      printf  $banh  "Stop time     %s\n", ${${${$ptr_ref}{stop}}}{assert};
      printf  $banh  "\n";

      my $transaction      = ${${${$ptr_ref}{start}}}{transaction};
      my $bytes_transfered = 0;
      my $bytes_read       = 0;
      my $bytes_write      = 0;

      my $total_time       = 0;
      my $total_idle       = 0;
      my $total_addr       = 0;
      my $total_data       = 0;
      my $total_busy       = 0;
                               
      #  $write_payload              += $totalbeat * ${$ptr_cur_cmd}{burst_size} if ( ${$ptr_cur_cmd}{direction} =~ m/WR/ );
      #  $read_payload               += $totalbeat * ${$ptr_cur_cmd}{burst_size} if ( ${$ptr_cur_cmd}{direction} =~ m/RD/ );

      do {
          my ($direction, $ctype) = split /-/ , ${$ptr_cur_cmd}{direction};                             # extract direction information
          my $payload             =             ${$ptr_cur_cmd}{payload};                               # extract payload [byte] information
          my $phase               = ($ctype eq 'NONSEQ') ? 'ADDR' : 'IDLE';                             # NONSEQ,   IDLE, SEQ/DATA, BUSY      Recoding  ADDR
          my $cmd                 = ($direction eq 'RD') ? 'READ' : 'WRITE';                            # Encode    READ vs RD; WRITE vs WR   Recoding  READ/WRITE
          my $idle                = ${$transfer_ref}{$transaction}{IDLE}{duration};                     # IDLE phase
          my $addr                = ${$transfer_ref}{$transaction}{ADDR}{duration};                     # ADDR phase
          my $data                = ${$transfer_ref}{$transaction}{DATA}{total}{duration};              # DATA phase
          my $busy                = ${$transfer_ref}{$transaction}{BUSY}{total}{duration};              #            WAIT  states
          my $L                   = ${$transfer_ref}{$transaction}{ADDR}{length};                       # LAST beat  Burst length
          my $concealed           = ${$transfer_ref}{$transaction}{ADDR}{concealed};                    # Visible/concealed ADDR phase

          printf $banh "%*s %s %10s\n"  ,12, '', 'Transaction:', $transaction;
          printf $banh "%*s %s %10s\n"  ,12, '', 'Direction  :', $cmd;
          printf $banh "%*s %s %10s%s\n",12, '', 'BurstLength:', $L,' beat';
          printf $banh "%*s %s %10s\n"  ,12, '', 'Addr Phase :', ($concealed =~ m/NOT/ )
                                                               ? 'visible'
                                                               : 'concealed';
          printf $banh "%*s %s %10s\n"  ,12, '', 'IDLE Phase :', $idle  if (     $idle  > 0      );     # NOT Back2Back    commands
          printf $banh "%*s %s %10s\n"  ,12, '', 'ADDR Phase :', $addr  if ($concealed =~ m/NOT/ );     # No  interleaving commands
          printf $banh "%*s %s %10s\n"  ,12, '', 'DATA Phase :', $data  if (     $data  > 0      );     # Should be always true
          printf $banh "%*s %s %10s\n"  ,12, '', 'BUSY Phase :', $busy  if (     $busy  > 0      );     # In case of WAIT states
          printf $banh "\n"; # Spacer

          $total_time   += $idle + $data;
          $total_time   += $addr  if ($concealed =~ m/NOT/ );

          $total_idle   += $idle;
          $total_addr   += $addr  if ($concealed =~ m/NOT/ );
          $total_data   += $data;
          $total_busy   += $busy;

          ${$bandwidth_ref}{$cmd}{addr}     += $addr if ($concealed =~ m/NOT/ );
          ${$bandwidth_ref}{$cmd}{data}     += $data;
          ${$bandwidth_ref}{$cmd}{busy}     += $busy;
          ${$bandwidth_ref}{$cmd}{time}     += $addr if ($concealed =~ m/NOT/ );
          ${$bandwidth_ref}{$cmd}{time}     += $data;

          ${$bandwidth_ref}{ALL}{payload}   += $payload;
          ${$bandwidth_ref}{$cmd}{payload}  += $payload;
          
          $transaction++;
          $ptr_cur_cmd   = ${$ptr_cur_cmd}{next};

      } until ($ptr_cur_cmd == $ptr_fst_cmd );

      ${$bandwidth_ref}{ALL}{totaltime} = $total_time;
      ${$bandwidth_ref}{ALL}{totalidle} = $total_idle;
      ${$bandwidth_ref}{ALL}{totaladdr} = $total_addr;
      ${$bandwidth_ref}{ALL}{totaldata} = $total_data;
      ${$bandwidth_ref}{ALL}{totalbusy} = $total_busy;
      
      printf $banh "\n\n";
      printf $banh "%*s %s %10s %s\n" ,12, '', 'Total Time :',$total_time, $tb; 
      printf $banh "\n";
      printf $banh "%*s %s %10s %s\n" ,12, '', 'Total Idle :',$total_idle, $tb; 
      printf $banh "%*s %s %10s %s\n" ,12, '', 'Total Addr :',$total_addr, $tb; 
      printf $banh "%*s %s %10s %s\n" ,12, '', 'Total Data :',$total_data, $tb; 
      printf $banh "%*s %s %10s %s\n" ,12, '', 'Total Busy :',$total_busy, $tb; 
      printf $banh "\n";
      printf $banh "%*s %s %10s %s\n" ,12, '', 'Total Idle :',${$bandwidth_ref}{ALL}{totalidle}, $tb; 
      printf $banh "%*s %s %10s %s\n" ,12, '', 'READ  Time :',${$bandwidth_ref}{READ}{time}    , $tb;
      printf $banh "%*s %s %10s %s\n" ,12, '', 'READ  Busy :',${$bandwidth_ref}{READ}{busy}    , $tb;
      printf $banh "%*s %s %10s %s\n" ,12, '', 'WRITE Time :',${$bandwidth_ref}{WRITE}{time}   , $tb;
      printf $banh "%*s %s %10s %s\n" ,12, '', 'WRITE Busy :',${$bandwidth_ref}{WRITE}{busy}   , $tb;
      printf $banh "\n";
      printf $banh "%*s %s %10s %s\n" ,12, '', 'Payload    :',${$bandwidth_ref}{ALL}{payload}  ,'btye'; 
      printf $banh "%*s %s %10s %s\n" ,12, '', '   READ    :',${$bandwidth_ref}{READ}{payload} ,'btye'; 
      printf $banh "%*s %s %10s %s\n" ,12, '', '   WRITE   :',${$bandwidth_ref}{WRITE}{payload},'btye'; 
      close( $banh );
      printf $proh  "     closing    bandwidth log %s\n", $logfile;
      printf $proh " ... bandwidth  analysis new done\n";
}#sub bandwidth_analysis


sub   report_info {
      my ( $trace_header_ref                    # Trace information
         , $ptr_ref                             # transaction trace pointer
         , $opts_ref      ) = @_;               # command line arguments

      my $cycle       = ${$trace_header_ref}{period};                       # (float)
      my $tb          = ${$trace_header_ref}{timebase};                     # =  $6; # (ns|ps)
      my $frequency   = ${$trace_header_ref}{frequency};                    # (float)
      my $fb          = ${$trace_header_ref}{freqbase};                     # (MHz|GHz)
      my $logfile     = ${$opts_ref}{window};
      my $transaction = 0;

      printf " ... initialize transfer analysis\n";
      printf " %s\n", '='x80;
      printf " Tracefile : %s\n"           , $Trace{tracefile};
      printf " Logfile   : %s\n"           , $logfile; 
      printf " Script    : %s %s\n"        , $0, $VERSION;           #  0  1, 2,    3,   4,    5,    6,    7,     8
      printf " Date      : %4s-%02s-%02s\n", 1900+$year,$mon,$cday;  # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf " Time      : %4s:%02s:%02s\n", $h, $m,$s;              # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf " Cycle     : %10s %s\n"      , $cycle, $tb;
      printf " Frequency : %10s %s\n",     , $frequency, $fb;
      printf " %s\n", '='x80;
      
      ${$opts_ref}{from}  = ${${${$ptr_ref}{first}}}{assert} if ( !defined ${$opts_ref}{from}  );   # Set default
      ${$opts_ref}{until} = ${${${$ptr_ref}{last}}}{assert}  if ( !defined ${$opts_ref}{until} );   # Set default

      printf " TraceStart: %10s %s\n"      , ${${${$ptr_ref}{first}}}{assert}, $tb;
      printf " TraceEnd  : %10s %s\n"      , ${${${$ptr_ref}{last }}}{assert}, $tb;
      printf " Starting  : %10s %s\n"      , ${$opts_ref}{from}              , $tb;
      printf " Ending    : %10s %s\n"      , ${$opts_ref}{until}             , $tb;

      open (my $winh, ">$logfile")        || die " Can not create log $logfile";

      if ( ${$opts_ref}{from}   < ${${${$ptr_ref}{first}}}{assert} ) {
           printf " Starting time point out of bound to the lower side of trace window\n";
      }
      if ( ${$opts_ref}{from}   > ${${${$ptr_ref}{last }}}{assert} ) {
           printf " Starting time point out of bound to the upper side of trace window\n";
      }
      if ( ${$opts_ref}{until}  < ${${${$ptr_ref}{first}}}{assert} ) {
           printf " Ending   time point out of bound to the lower side of trace window\n";
      }
      if ( ${$opts_ref}{until}  > ${${${$ptr_ref}{last }}}{assert} ) {
           printf " Ending   time point out of bound to the upper side of trace window\n";
      }
     #if ( ${$opts_ref}{until} <= ${$opts_ref}{from} ) {
      if ( ${$opts_ref}{until}  < ${$opts_ref}{from} ) {        # The start and end time would select just one Transfer
          printf  " Ending   time is earlier than the Starting time :: Contradiction !!\n";
      }
      
      my $stop_ptr   =   ${${$ptr_ref}{first}};                 # Set buffer stop pointer
      my $search_ptr =   ${${$ptr_ref}{first}};                 # Set search      pointer to the FIRST  pointer of Transfer List
      my $next_ptr   = ${${${$ptr_ref}{first}}}{next};          # Set lookahead   pointer to the NEXT   pointer of Transfer List

      do {
          #
          #  1) Transfer assertion is earlier   as   the START window
          #
          #  2) Transfer assertion is identical with the START window
          #
          #  3) Transfer assertion is past           the START window
          #
          $transaction++;
          printf $winh "%*s %s  %15s\n"  , 8,'', 'Transaction ', $transaction;
          printf $winh "%*s %s  %15s\n"  , 8,'', 'TransferTime', ${$search_ptr}{assert};
          printf $winh "%*s %s  %15s"    , 8,'', 'Pointer     ', $search_ptr;
          
          if (  ${$search_ptr}{assert}  == ${$opts_ref}{from}       # Set START       pointer as the BEGIN  pointer in Transfer List
                                                                    # specifically    if at      FIRST    and ULTIMARE    transfer
             ||(${$search_ptr}{assert}   < ${$opts_ref}{from} &&    #                 if between                any two   transfers
                ${$next_ptr  }{assert}   > ${$opts_ref}{from}   )   # specifically    if between ULTIMATE and PENULTIMATE transfer
             ) {   
                ${${$ptr_ref}{start}}    = $search_ptr;
                printf $winh "\t%s  %15s", 'STARTWINDOW ', ${${$ptr_ref}{start}};
          }
          if (  ${$search_ptr}{assert}  == ${$opts_ref}{until}      # Set END         pointer as the ENDING pointer in Transfer List
                                                                    # specifically    if at      ULTIMATE or at any other transfer
             ||(${$search_ptr}{assert}   < ${$opts_ref}{until} &&   #                 if between                any two   transfers
                ${$next_ptr  }{assert}   > ${$opts_ref}{until}   )  # specifically    if between ULTIMATE and PENULTIMATE transfer
             ) {
                ${${$ptr_ref}{stop}}     = $search_ptr;
                printf $winh "\t%s  %15s", 'STOP WINDOW ', ${${$ptr_ref}{stop}};                
          }
          printf $winh "\n";
          $search_ptr = ${$search_ptr}{next};
          $next_ptr   = ${$search_ptr}{next};                   #

      } until ($search_ptr == $stop_ptr );
      
      printf "START pointer %s\n", ${${$ptr_ref}{start}};
      printf "STOP  pointer %s\n", ${${$ptr_ref}{stop}};
      
}#sub report_info


sub   analysis_report{
      my (  $trace_header_ref                                                       # input     Trace   information from trace file header
         ,  $opts_ref                                                               #           Command line options
         ,  $latency_ref                                                            #           reference to %ahb_latency_new
         ,  $transfer_ref                                                           #           reference to %%ahb_transfer new
         ,  $bandwidth_ref                                                          #           reference to %%ahb_bandwidth_new
         ,  $transaction_ref ) = @_;                                                #           reference to %%ahb_transaction_new

      my $logfile     = ${$opts_ref}{report};
       
      #my $tr   = ${$trace_header_ref}{tracefile}    =  $1; # trace filename
      #my $prot = ${$trace_header_ref}{protocol}     =  $1; # (AHB)
      #my ${$trace_header_ref}{period}               =  $2; # (float)
      my $tb   = ${$trace_header_ref}{timebase};   # =  $6; # (ns|ps)
      #my ${$trace_header_ref}{redundant}            =  $7; # (AHB)
      #my ${$trace_header_ref}{frequency}            =  $8; # (float)
      #my ${$trace_header_ref}{freqbase}             = $12; # (MHz|GHz)
      #my ${$trace_header_ref}{databus}              = $13; # bit width
      my $scale = ($tb eq 'ms')?                      1000  # ms
                : ($tb eq 'us')?               1000 * 1000  # us
                : ($tb eq 'ns')?        1000 * 1000 * 1000  # ns
                : ($tb eq 'ps')? 1000 * 1000 * 1000 * 1000  # ps
                :         1000 * 1000 * 1000 * 1000 * 1000; # fs
      my $giga  =  1000 * 1000 * 1000;
      my $length_of_line = 91;

      printf  $proh "\n";
      printf  $proh " ... printing analysis report \n";
      printf  $proh  "     opening    analysis report %s\n" ,$logfile;
      open(my $anah, ">$logfile")|| die " Can not create log $logfile";             # Analysis Report
      printf  $anah "Trace file     : %s\n",     ${$trace_header_ref}{tracefile} ;
      printf  $anah "Protocol       : %s\n",     ${$trace_header_ref}{protocol};
      printf  $anah "Data bus width : %s bit\n", ${$trace_header_ref}{databus};
      printf  $anah "Convention     : SI : giga = 1 000 000 000 = 10^9\n"; # IEC 2^10 gibibit JEDEC 
      printf  $anah "                      mega =     1 000 000 = 10^6\n";
      printf  $anah "                      kilo =         1 000 = 10^3\n";

      printf  $anah "\n\n";
      printf  $anah "%s\n", '='x$length_of_line;
      printf  $anah "Last  Data Latency ( Latency = Last  Data HREADY Assert time - Address HREADY Assert time )\n";
      printf  $anah "%s\n", '='x$length_of_line;
      printf  $anah "\n";
      printf  $anah " %s : %9s\n"        , '        total       transaction number', ${$latency_ref}{L}{ALL  }{number};
      printf  $anah " %s : %13.3f %s\n"  , 'minimum transaction completion latency', ${$latency_ref}{L}{ALL  }{minimum}, $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'average transaction completion latency', ${$latency_ref}{L}{ALL  }{average}, $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'maximum transaction completion latency', ${$latency_ref}{L}{ALL  }{maximum}, $tb;
      printf  $anah "\n";
      printf  $anah " %s : %9s\n"        , '        READ        transaction number', ${$latency_ref}{L}{READ }{number};
      printf  $anah " %s : %13.3f %s\n"  , 'minimum READ        completion latency', ${$latency_ref}{L}{READ }{minimum}, $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'average READ        completion latency', ${$latency_ref}{L}{READ }{average}, $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'maximum READ        completion latency', ${$latency_ref}{L}{READ }{maximum}, $tb;
      printf  $anah "\n";
      printf  $anah " %s : %9s\n"        , '        WRITE       transaction number', ${$latency_ref}{L}{WRITE}{number};
      printf  $anah " %s : %13.3f %s\n"  , 'minimum WRITE       completion latency', ${$latency_ref}{L}{WRITE}{minimum}, $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'average WRITE       completion latency', ${$latency_ref}{L}{WRITE}{average}, $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'maximum WRITE       completion latency', ${$latency_ref}{L}{WRITE}{maximum}, $tb;
      printf  $anah "\n";
 
      printf  $anah "\n\n";
      printf  $anah "%s\n", '='x$length_of_line;
      printf  $anah "First Data Latency ( Latency = First Data HREADY Assert time - Address HREADY Assert time )\n";
      printf  $anah "%s\n", '='x$length_of_line;
      printf  $anah "\n";
      printf  $anah " %s : %9s\n"        , '        total       transaction number', ${$latency_ref}{1}{ALL  }{number};
      printf  $anah " %s : %13.3f %s\n"  , 'minimum transaction completion latency', ${$latency_ref}{1}{ALL  }{minimum}, $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'average transaction completion latency', ${$latency_ref}{1}{ALL  }{average}, $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'maximum transaction completion latency', ${$latency_ref}{1}{ALL  }{maximum}, $tb;
      printf  $anah "\n";
      printf  $anah " %s : %9s\n"        , '        READ        transaction number', ${$latency_ref}{1}{READ }{number};
      printf  $anah " %s : %13.3f %s\n"  , 'minimum READ        completion latency', ${$latency_ref}{1}{READ }{minimum}, $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'average READ        completion latency', ${$latency_ref}{1}{READ }{average}, $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'maximum READ        completion latency', ${$latency_ref}{1}{READ }{maximum}, $tb;
      printf  $anah "\n";
      printf  $anah " %s : %9s\n"        , '        WRITE       transaction number', ${$latency_ref}{1}{WRITE}{number};
      printf  $anah " %s : %13.3f %s\n"  , 'minimum WRITE       completion latency', ${$latency_ref}{1}{WRITE}{minimum}, $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'average WRITE       completion latency', ${$latency_ref}{1}{WRITE}{average}, $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'maximum WRITE       completion latency', ${$latency_ref}{1}{WRITE}{maximum}, $tb;
      printf  $anah "\n";
      
      printf  $anah "\n\n";
      printf  $anah "%s\n", '='x$length_of_line;
      printf  $anah " Bandwidth Analysis\n";
      printf  $anah "%s\n", '='x$length_of_line;
      printf  $anah "\n";
   
      printf  $anah " %s : %9s %*s\n"    , 'Total  transfered   amount of data    ',${$bandwidth_ref}{ALL}{payload}   , 8,'byte';
      printf  $anah " %s : %9s %*s\n"    , 'Total  READ         amount of data    ',${$bandwidth_ref}{READ}{payload}  , 8,'byte';
      printf  $anah " %s : %9s %*s\n"    , 'Total  WRITE        amount of data    ',${$bandwidth_ref}{WRITE}{payload} , 8,'byte';
      printf  $anah "\n\n";

      printf  $anah " %s : %13.3f %s\n"  , 'Total  traced       period            ',${$bandwidth_ref}{ALL}{totaltime} , $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'Total  READ         time              ',${$bandwidth_ref}{READ}{time}     , $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'Total  WRITE        time              ',${$bandwidth_ref}{WRITE}{time}    , $tb;
      printf  $anah " %s : %13.3f %s\n"  , 'Total  IDLE         time              ',${$bandwidth_ref}{ALL}{totalidle} , $tb;
      printf  $anah "\n\n"; 

      printf  $anah " %s : %13.3f byte/s", 'Total  Bandwith     consumed          ',${$bandwidth_ref}{ALL}{payload}  /  ${$bandwidth_ref}{ALL}{totaltime} * $scale;
      printf  $anah " %10.3f Gbit/s\n"                                             ,${$bandwidth_ref}{ALL}{payload}  /  ${$bandwidth_ref}{ALL}{totaltime} * $scale / $giga * 8;
      printf  $anah " %s : %13.3f byte/s", 'READ   Bandwith     consumed          ',${$bandwidth_ref}{READ}{payload} /  ${$bandwidth_ref}{READ}{time}     * $scale;
      printf  $anah " %10.3f Gbit/s\n"                                             ,${$bandwidth_ref}{READ}{payload} /  ${$bandwidth_ref}{READ}{time}     * $scale / $giga * 8;
      printf  $anah " %s : %13.3f byte/s", 'WRITE  Bandwith     consumed          ',${$bandwidth_ref}{WRITE}{payload}/  ${$bandwidth_ref}{WRITE}{time}    * $scale;
      printf  $anah " %10.3f Gbit/s\n"                                             ,${$bandwidth_ref}{WRITE}{payload}/  ${$bandwidth_ref}{WRITE}{time}    * $scale / $giga * 8;
      printf  $anah "\n\n";
      report_transactions ( $anah                   #   filehandle
                          , $transaction_ref        #   %ahb_transaction
                          , 91               );     #   length of a report line

      #======================================================================================================================================

      printf  $anah "\n\n";
      printf  $anah "%s\n", '='x$length_of_line;
      printf  $anah " Latency per transaction\n";
      printf  $anah "%s\n", '='x$length_of_line;
      printf  $anah "\n\n";

      printf  $anah "Transaction\t\tTransaction\t\tSample time\t\tSample time\t\t    Latency\t\t    Latency\n";
      printf  $anah "\t number\t\t  assertion\t\t first_data\t\t  last_data\t\t first_data\t\t  last_data\n";      # Version 1.01.05 header
      printf  $anah "%s\n", '='x$length_of_line;

      # Version 1.01.06
      foreach my $transaction ( sort { $a <=> $b } keys %{$transfer_ref } ) {                                     # Sort numerically
          my $L = ${$transfer_ref}{$transaction}{ADDR}{length};                                                   # Last DATA beat, burst length
          printf $anah "#%10s"    , $transaction;                                                                 # First  column Transaction Number
          printf $anah "\t%12s %s", ${$transfer_ref}{$transaction}{ADDR}{transferstop}    , $tb;                  # Second column       ADDR transfer done 
          printf $anah "\t%12s %s", ${$transfer_ref}{$transaction}{DATA}{ 1}{transferstop}, $tb;                  # Third  column 1st   DATA transfer done 
          printf $anah "\t%12s %s", ${$transfer_ref}{$transaction}{DATA}{$L}{transferstop}, $tb;                  # Fourth column Last  DATA transfer done 
          printf $anah "\t%12s %s", ${$transfer_ref}{$transaction}{DATA}{ 1}{duration}    , $tb;                  # Fifth  column 1st   DATA transfer period 
          printf $anah "\t%12s %s", ${$transfer_ref}{$transaction}{DATA}{total}{duration} , $tb;                  # Sixth  column total DATA transfer period 
          printf $anah "\n";    
      }#foreach transaction/cmd NOT transfer

      printf $anah "%s\n", '='x$length_of_line;
      printf $anah "End of Analysis Report\n";
      printf $anah "%s\n", '='x$length_of_line;
      close( $anah );

      printf $proh  "     closing    analysis report %s\n", $logfile;
      printf $proh " ... printing analysis report done \n";
      printf " ... %s trace analysis done\n",$Trace{protocol}  ;
}#sub analysis_report


sub   transaction_analysis {
      my ( $trace_header_ref                    # Trace information
         , $trace_ref                           # Reference to global %AHB_hash, holding all ADDR transfers/ AHB transactions
                                                #                                no DATA transfers are included in %AHB_hash
         ,  $opts_ref                                                               #           Command line options
         , $transaction_ref ) = @_;             # %ahb_transaction_new

      my $logfile     =         ${$opts_ref}{report};
      my $cycle       = ${$trace_header_ref}{period};                               # (float)
      my $tb          = ${$trace_header_ref}{timebase};                             # =  $6; # (ns|ps)
      my $frequency   = ${$trace_header_ref}{frequency};                            # (float)
      my $fb          = ${$trace_header_ref}{freqbase};                             # (MHz|GHz)
     # my $ptr_cur_cmd = ${${$ptr_ref}{start}};                                      # Initialize starting point in transaction list 
     # my $buffer_stop = ${${$ptr_ref}{stop}};  

      printf  $proh  "\n";
      printf  $proh  " ... transaction analysis\n";
      open(my $cmdh, ">$logfile")|| die " Can not create log $logfile";             # Command as in Transaction 
      printf  $cmdh  " %s\n", '='x80;
      printf  $cmdh  " Tracefile : %s\n"           , $Trace{tracefile};
      printf  $cmdh  " Logfile   : %s\n"           , $logfile; 
      printf  $cmdh  " Script    : %s %s\n"        , $0, $VERSION;           #  0  1, 2,    3,   4,    5,    6,    7,     8
      printf  $cmdh  " Date      : %4s-%02s-%02s\n", 1900+$year,$mon,$cday;  # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf  $cmdh  " Time      : %4s:%02s:%02s\n", $h, $m,$s;              # $s,$m,$h,$cday,$mon,$year,$wday,$yday,$isdst
      printf  $cmdh  " Cycle     : %10s %s\n"      , $cycle, $tb;
      printf  $cmdh  " Frequency : %10s %s\n",     , $frequency, $fb;
      printf  $cmdh  " %s\n", '='x80;

      foreach my $timestamp (sort { $a <=> $b } keys %{$trace_ref}) {           # The order is chronologic
          my $direction  = ${${$trace_ref}{$timestamp}}{direction};
          my $burst_type = ${${$trace_ref}{$timestamp}}{burst_type};
          my $burst_size = ${${$trace_ref}{$timestamp}}{burst_size};
          ${$transaction_ref}{transaction}{total}                               += 1;  # accounting starts with counting
          ${$transaction_ref}{transaction}{$burst_type}                         += 1;
          if ($direction =~ m{WR-NONSEQ} ){
              ${$transaction_ref}{transaction}{WRITE}{total}                    += 1;
              ${$transaction_ref}{transaction}{WRITE}{$burst_type}              += 1;
              ${$transaction_ref}{transaction}{$burst_size}{WRITE}{total}       += 1;
              ${$transaction_ref}{transaction}{$burst_size}{WRITE}{$burst_type} += 1;
          }
          if ($direction =~ m{RD-NONSEQ} ){
              ${$transaction_ref}{transaction}{READ}{total}                     += 1;
              ${$transaction_ref}{transaction}{READ}{$burst_type}               += 1;
              ${$transaction_ref}{transaction}{$burst_size}{READ}{total}        += 1;
              ${$transaction_ref}{transaction}{$burst_size}{READ}{$burst_type}  += 1;
          }
          printf $cmdh "%6s # %12s\n", ${$transaction_ref}{transaction}{total}, $timestamp;
      }#foreach
      report_transactions ( $cmdh                   #   filehandle
                          , $transaction_ref        #   %ahb_transaction
                          , 91               );     #   length of a report line
      close  $cmdh;
      printf $proh  "     closing    transaction log %s\n", $logfile;
      printf $proh  " ... transaction analysis done\n";
}#sub transaction_analysis


sub report_transactions {
    my (    $fileh
       ,    $transaction_ref
       ,    $length_of_line
       ) = @_;

    printf $fileh "%s\n", '='x$length_of_line;
    printf $fileh " Transaction Overview\n";
    printf $fileh "%s\n", '='x$length_of_line;
    printf $fileh "\n";

    my @_list = ( "SINGLE", "INCR", "INCR4", "INCR8", "INCR16", "WRAP4", "WRAP8", "WRAP16", "total" );
    printf $fileh "   TOTAL transactions :: (by type)\n";
    foreach my $type ( @_list ){
        printf $fileh "   %8s : %4s transactions\n", $type, ${$transaction_ref}{transaction}{$type};
    }
    printf $fileh "%s\n", '-'x$length_of_line;
    printf $fileh "   WRITE transactions :: (by type)\n";
    foreach my $type ( @_list ){
        printf $fileh "   %8s : %4s transactions\n", $type, ${$transaction_ref}{transaction}{WRITE}{$type};
    }
    printf $fileh "%s\n", '-'x$length_of_line;
    printf $fileh "   READ  transactions :: (by type)\n";
    foreach my $type ( @_list ){
        printf $fileh "   %8s : %4s transactions\n", $type, ${$transaction_ref}{transaction}{READ}{$type};
    }
    printf $fileh "\n";
    printf $fileh "%s\n", '='x$length_of_line;
    printf $fileh "   WRITE transactions :: (by size, type)\n";
    foreach my $size ( ( 1, 2, 4 ) ){   # byte
        printf $fileh "   %s byte wide burst\n", $size;
        foreach my $type ( @_list ) {
            printf $fileh "   %8s : %4s transactions\n", $type, ${$transaction_ref}{transaction}{$size}{WRITE}{$type};
        }# by type
        printf $fileh "%s\n", '-'x$length_of_line;
    }#by size
    printf $fileh "%8s : %4s transactions\n", "Total WRITE", ${$transaction_ref}{transaction}{WRITE}{total};

    printf $fileh "\n";
    printf $fileh "%s\n", '='x$length_of_line;
    printf $fileh "   READ  transactions :: (by size, type)\n";
    foreach my $size ( ( 1, 2, 4 ) ){   # byte
        printf $fileh "   %s byte wide burst\n", $size;
        foreach my $type ( @_list ) {
            printf $fileh "   %8s : %4s transactions\n", $type, ${$transaction_ref}{transaction}{$size}{READ}{$type};
        }# by type
        printf $fileh "%s\n", '-'x$length_of_line;
    }# by size
    printf $fileh "%8s : %4s transactions\n", "Total READ ", ${$transaction_ref}{transaction}{READ}{total};
    printf $fileh "%s\n", '='x$length_of_line;
}#sub report_transactions 

sub list_hash {
    my ($href) = @_;
    foreach my $entry ( keys %{$href} ){
        printf "\n", ;
    }#foreach
}#sub list_hash
